%\section{Granary}
This chapter provides background information about Granary~\cite{GranaryAtOSDI}, on which we build our watchpoints. Granary is a dynamic binary translation (DBT) framework designed to instrument kernel modules, which are %. Behavioral watchpoint framework is implemented using Granary. The aim of behavioral watchpoint is to analyse and debug kernel modules, which are 
a frequent source of bugs and vulnerabilities in operating systems \cite{BGI,LXFI}. %Kernel modules extend the functionality of operating systems (OSes). Modules are used to support new devices (e.g. network and graphics cards) and provide new features (e.g. file systems). %The kernel and its modules execute in a complex and dynamic environment. %Understanding how modules behave in and affect this environment is important.   

Granary instruments arbitrary, binary Linux kernel modules efficiently and without imposing overhead when the core kernel is running. Granary is unique among DBT frameworks because it analyzes and uses program type information. For example, Granary can substitute the execution of a function with a \emph{wrapped} version of itself. A wrapped function has the same type specification as its unwrapped counterpart and can freely modify its arguments and return value. Granary can wrap some module functions in this way, even if the module source code is unavailable. Granary is designed with three goals for practical module analysis: i) comprehensively analyze \emph{all} modules; ii) impose no performance overheads on non-module kernel code; iii) require no changes to modules and minimal changes to the kernel, so that it can be easily ported between different hardware and kernel versions. Granary meets all these goals as follows:

\begin{enumerate}
	\item Granary is comprehensive because it controls and instruments the execution of all module code. Granary maintains control by ensuring that normal module code is never executed. Instead, only decoded and translated module code is executed. Translated module code contains instrumentation and always yields control back to Granary. %All modules can be instrumented in this way because dynamic binary translation operates on binaries and does not depend on any hardware features.
	The ability to comprehensively instrument the kernel modules help enables implementing watchpoints on an arbitrary memory reference.%behavioral watchpoint framework inspect every memory references and inject instrumentation to access watchpoints.
	\item Kernel code runs without overhead because Granary relinquishes control whenever an instrumented module executes kernel code. Granary implements a novel technique for re-gaining control when kernel code attempts to execute module code. Each time the instrumented module code invokes a kernel function, all arguments of the function are \emph{wrapped}. Argument wrappers are type- and function-specific, and ensure that potential module entry points (e.g. module function pointers) are replaced with behaviorally-equivalent values that first yield control to Granary. The type- and function-specific wrappers provide the behavioral watchpoint framework the ability to add type information with the watchpoints. They also help the watchpoint framework identify kernel allocators and wrap them to add watchpoints on newly allocated objects. 
	\item Granary does not require any changes in the module or the kernel code. Granary's wrapping mechanism is portable across different kernel versions because the majority of wrappers are automatically generated by parsing kernel headers and using several meta-programs.
\end{enumerate}



Granary interposes on the Linux kernel's module loading process. When a kernel module is loaded, Granary bootstraps by translating the first basic block of the module's initialisation function.  It then replaces the pointer to that function with a pointer to the translated basic block. The translation process continues when the kernel initialises the module by invoking the translated module code.

Granary translates and instruments module binaries on demand (one basic block at a time). The new basic blocks are decoded and translated as execution ``discovers'' those basic blocks. Translated basic blocks are linked together and stored in a globally accessible \emph{code cache}. %In Granary, a basic block is a sequence of instructions ending in a conditional branch, \texttt{ret}, or \texttt{jmp}, but not a \texttt{call} instruction.
Granary's just-in-time translation approach means that code executing from the code cache may yield control to Granary to request the address of the next basic block to execute. When instrumented code yields to Granary, a ``context switch'' occurs that transfers execution to a CPU-private stack where Granary operates. Granary context-switches back to the code cache when the next basic block has been found or translated so that instrumented execution may continue. 

Granary provides three important features that are helpful in developing DBT-based program analysis tools.

%Similar to other DBT systems, Granary uses caching and hotpatching to reduce the number of context switches. %In our experience, modules stabilise very quickly: context switches stop happening after most module basic blocks have been translated.

%Basic blocks in Granary's code cache contain \texttt{x86-64} binary instructions and meta-data describing those instructions. The meta-data that Granary records in each basic block includes: \begin{inparaenum}[i)]
%	\item the length in bytes of the original and translated basic blocks;
%	\item the address of the first instruction in the original basic block; and
%	\item the policy information (e.g., $P_{\mathit{call\_entry}}$, $P_{\mathit{after\_entry}}$) used to instrument the basic block.
%\end{inparaenum} %This meta-data can be queried and extended by Granary instrumentation tools. %For example, Granary's CFG-building tool represents each node in the inter- and intra-procedural CFGs as an extension of the meta-data stored for each basic block. The meta-data is also queried by interrupt handlers when deciding how to handle interrupts in instrumented code, and by debuggers (e.g., \texttt{gdb}) to give contextual information about a translated basic block. 

%The implication of this approach is that code executing from

%Granary employs a just-in-time (JIT) translation strategy: input executable code is translated one basic block at a time. Translation occurs on-demand: a basic block from the input code is only translated when an attempt is made to execute that block (assuming it has not already been translated). 

%This approach is ideal for \texttt{x86} architectures, where instructions can be overlayed or mixed with data, because Granary will ``discover'' the entrypoints to basic blocks in the input code as the program attempts to execute those basic blocks.

%A dynamic binary translator is a binary-to-binary compiler: executable code is consumed as input, then decoded, translated, instrumented, and finally re-encoded.  We define translation and instrumentation as follows: \begin{description}
%	\item[Translation] involves modifying (and potentially adding) instructions so that execution behaviour is maintained. For example, some instructions cannot be arbitrarily relocated (e.g. instruction pointer-relative memory loads) without minor adjustment. Translation involves ``fixing'' these instructions so that they will work as expected when executed.
%	\item[Instrumentation] involves adding instructions to the program. Instructions are added during the instrumentation phase to augment the program to achieve some secondary goal (e.g. profiling, debugging).
%\end{description}

%DBT systems are dynamic insofar as compilation occurs at runtime instead of ahead-of-time. 

%This approach is ideal for \texttt{x86} architectures because basic blocks in the control-flow graph are ``discovered'' as execution traverses that graph. Attempting to translate the entire control-flow graph before executing it is non-trivial because \texttt{x86} instructions can be overlayed or mixed with data.


%A JIT-based strategy is ideal for the \texttt{x86} architecture because instructions and data can be mixed, and instructions can be overlayed on top of each other. These two issues make determining the full control-flow graph of an arbitrary executable intractable.
%which makes it intractable to statically determine the full set of executable instructions within a given binary.
% because overlayed instructions and mixed instructions/data make it impossible to know ahead of time.
% might contain a prefix of another instruction, which can be the target of 

%Generally, DBT systems attempt to maintain two properties: comprehensiveness, transparency, and efficiency

%\paragraph{Comprehensiveness} A DBT system is comprehensive if translated/instrumented code always executes in place of original code. Comprehensiveness is related to control: a DBT system must control of the execution of all instrumented code. If control is relinquished (i.e. execution enters native, uninstrumented code) then comprehensiveness is at risk. In \Cref{sec:modes}, we describe how Granary maintains comprehensiveness, even when control is relinquished.

%For example, if control is relinquished and some natively executing code is allowed to execute some 

% if some native code attempts to execute some input code meant for instrumentation then comprehensiveness is lost if the DBT system is unable to regain control and direct execution to the instrumented version of the input code. 

%\paragraph{Transparency} A DBT system is transparent if instrumented and uninstrumented code behave in the same way given the same inputs and initial state. By default, Granary operates under a relaxed transparency model (\Cref{sec:transparency}); however, the higher levels of transparency can be enabled to the detriment of flexibility.

%\paragraph{Efficiency} A DBT system is efficient if the additional overhead resulting from instruction translation (absent instrumentation) is minimized. A discussion of all of the techniques employed by Granary to reduce its overhead is beyond the scope of this paper.

%In \Cref{sec:modes}, we describe how Granary maintains 
%DBT systems translate all or parts of a program binary into an instrumented binary, and ensure that only the instrumented binary ever execute.
%DBT systems are dynamic insofar as translation occurs at runtime, not ahead-of-time. 
%Granary is a just-in-time (FIT) based DBT system, which means that it incrementally translates a program binary into an instrumented binary. The benefits of JIT-based DBT systems are: \begin{inparaenum}[i)]
%	\item if some code is 
%\end{inparaenum}
%A DBT system is \emph{comprehensive} if it controls the execution of all instructions from a binary targeted for instrumentation. DBT systems ensure comprehensiveness by only allowing a translated copy of some original code to execute. This copied code continually yields control back to the DBT system, thus maintaining control.
%Comprehensive instrumentation of a binary by a DBT tool requires that the DBT tool be in control of all instructions executed from that binary. DBT tools do this by operating on short sequences of straight-line instructions ending in control-flow transfer instructions (CTIs), called \emph{basic blocks}. Basic blocks are translated so as to yield control to the DBT system so that the DBT system can direct execution to the next basic block. The dispatcher translates and transfers control to new basic blocks, thus emulating the behaviour of the original CTIs. Control remains with the tool to the extent that only translated versions of non-CTIs (e.g. arithmetic and memory instructions) from the original binary are executed natively, while all CTIs are emulated.
%Comprehensiveness also requires that a DBI tool hide and protect itself from the instrumented binary. Hiding is necessary for transparency: instrumentation should not change program semantics or behaviour. A program running with instrumentation should not be able to (easily) determine that it is being instrumented, lest it change its behaviour in response to being instrumented. Protection is necessary in the event that a module is intentionally or accidentally malicious. For example, if a malicious module subverted the control of the DBI tool then it could arbitrarily generate executable code and escape further instrumentation.
%Comprehensive DBI is challenging in user space, especially when dealing with multithreaded, multiprocessing, and asynchronous execution (signals). DBI is especially challenging in kernel space: interrupts and exceptions arbitrarily alter control flow, and interrupted kernel threads can resume their execution on different CPU cores.
%We built our framework on top of DynamoRIO Kernel (DRK). DRK is a kernel-space port of the user-space DynamoRIO DBI framework \cite{Bruening2004}. DRK comprehensively instruments all Linux kernel and module code, including interrupt and exception handlers, and works on multi-core processors \cite{Feiner2012}. Further, DRK maintains the precise interrupt delivery semantics of the x86 architecture.
%DRK is loaded as a kernel module and thereafter controls the execution of all kernel code. Execution of kernel code happens only from within DRK's code caches. DRK caches instrumented kernel code on a per-CPU basis. When DRK's dispatcher is invoked to complete a control-flow transfer to a previously un-executed instruction, it stores the newly translated basic block in the code cache of the current core. As an optimization, direct control-flow transfers are optimized to transfer control between two basic blocks in the code cache, instead of returning to the dispatcher. As with DynamoRIO, DRK exports an API to \emph{clients}, which allows programmers to plug their own instrumentation and translation policies into DRK. DRK takes care not to instrument user-space code: instrumentation \emph{attaches} when user code is interrupted or invokes a system call, and \emph{detaches} when execution returns to user space.



\begin{figure*}[t!]
\lstset{language=C, tabsize=2, stepnumber=1}
\begin{multicols}{2}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
struct device_driver {
	...
	int (*probe)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*suspend)(struct device *, 
						pm_message_t);
	int (*resume)(struct device *);
	...
	const struct dev_pm_ops *pm;
	...
};
\end{lstlisting}
\columnbreak
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
TYPE_WRAPPER(struct device_driver, {
    PRE_OUT {
        WRAP_FUNCTION(arg.probe);
        WRAP_FUNCTION(arg.remove);
        WRAP_FUNCTION(arg.shutdown);
        ...
    }
    POST_OUT {
        POST_WRAP(arg.pm);
    }
})
\end{lstlisting}
\end{multicols}

\caption[Type wrapper for Linux device driver structure]{The Linux device driver structure is shown on the left. The automatically generated type wrapper for this structure is shown on the right. In the wrapper code, \texttt{arg} is a reference to a \texttt{struct device\_driver} object passed as, or referenced by, an argument to a kernel or module wrapper. Code in the \texttt{PRE\_OUT} section is applied to arguments of the wrapped type before a kernel wrapper is invoked. Similarly, code in the \texttt{POST\_OUT} section is applied to arguments of the wrapped type after a kernel wrapper is invoked. \texttt{POST\_WRAP} invokes the type wrapper that is specific to the value to which it is applied (\texttt{arg.pm}). Type wrappers also support \texttt{\_IN} suffixes instead of \texttt{\_OUT} suffixes, which apply to data going into modules (i.e., over module wrappers). Finally, the \texttt{RETURN\_} prefix is used to apply some code to return values of either kernel or module wrappers.}
\label{fig:type_wrapper}
\end{figure*}

\section{Mixed-Mode Execution}\label{sec:modes}
Granary supports two modes of execution: instrumented and native. Module code is instrumented and executes from Granary's code cache, which is under Granary's control. Non-module kernel code runs natively. A mode switch occurs when execution transfers between native and instrumented code. Some mode switches happen naturally (e.g., when instrumented code returns to native code) and other mode switches are mediated by Granary (e.g., when instrumented module code invokes a kernel function).

The mode switch from instrumented module code to native kernel code is easier to detect since the instrumented code runs under Granary's control. Granary treats all kernel functions as \emph{detach} points, where a mode switch from instrumented to native code occurs. At these points, Granary stops executing. However, Granary needs a way to regain control when native kernel code invokes module code. Granary uses static analysis information to dynamically discover attach points by wrapping the kernel/module interface. Kernel functions are wrapped by \emph{kernel wrappers} that inspect and traverse argument pointers in search of pointers to module functions and replaces them with a function-specific module wrapper. Figure~\ref{fig:type_wrapper} shows an example of a type wrapper for Linux device driver structure which is used for wrapping function pointers. After the module initialisation process, the \emph{attaching} of Granary when module code starts executing, happens in one of three ways: \begin{enumerate}
	\item {\bf Implicit attaching:} It happens when kernel returns to the module. The native kernel code returns to instrumented module code in the code cache. This is done at the cost of return address transparency, i.e., code cache addresses are visible on returns to the executing module code.
	\item {\bf Fast attaching:} When the kernel invokes a wrapped module function. The addresses of these module wrapper functions are provided to the kernel through type wrapping at the interface.
	\item {\bf Slow attaching:} When the kernel invokes unwrapped module code. If the kernel executes an uninstrumented module function that was passed to the kernel in a type-unsafe manner, then the processor will raise a fault because Granary uses hardware page protection to prevent module code from being executed. Granary handles these faults by returning execution to the instrumented version of the faulting module code.
%Granary uses memory page protection to mark module code as non-executable, which helps Granary ensure comprehensiveness: if the kernel finds an ``alternate route'' to invoking module code (e.g., some module function is passed to the kernel in a type-unsafe manner and hence is passed unwrapped), then the processor will raise a fault instead of executing that code. Granary handles this fault by returning execution to the instrumented version of the faulting module code.
\end{enumerate}

%Fast and slow attaching transfer control to instrumented module code. Fast attaching is ``fast'' because the instrumented code address is computed once and emitted as part of the module function wrapper. Slow attaching is ``slow'' because Granary looks up the instrumented address associated with the faulting native address each time the fault occurs.

%\paragraph{Detaching}

Granary \emph{detaches} when control transfers from instrumented code to native (uninstrumented) code. Detaching occurs in one of two ways: \begin{enumerate}
	\item {\bf Implicit detaching:} Instrumented module code returns to the original kernel, or is interrupted (initial interrupt handling is done by the kernel and hence interrupt handling runs uninstrumented code).
	\item {\bf Wrapped detaching:} Instrumented module code invokes a kernel wrapper that later transfers control to the kernel.
\end{enumerate}

Mixed-mode execution provides Granary the ability to instrument only module code. However the attach/detach mechanism of Granary is more generic and it allows the instrumentation tool to switch the execution mode anytime. This selective instrumentation feature is used by the behavioral watchpoint framework to implement on-demand instrumentation. Granary's wrapper provides instrumentation tools information that is derived from static analysis of the kernel.

% Granary's wrapper approach has two benefits: (i) it is more efficient than the trap-based alternative, and (ii) it gives instrumentation tools more information about the executing module.

%--

%Granary's main approach to regaining control is based on the observation that modules tell the kernel about their interfaces by registering functions with the kernel.  



%We expect that at least some of the registered functions will be executed by the kernel because this is the mechanism by which modules extend the kernel's functionality. To Granary, registered module functions represent potential future \emph{attach} points, where a mode switch from native to instrumented code will occur. Furthermore, Granary discovers additional attach points at detach points by observing pointers to module functions that are passed by modules to the kernel.




%The fallback solution for regaining control uses hardware page protection to trap attempts by the kernel to execute native module code. We handle these traps by redirecting execution to instrumented module code. While comprehensive, this approach is not ideal because: \begin{inparaenum}[i)]
%	\item trapping on every execution attempt introduces overhead; and
%	\item the trap does not provide sufficient information about which interfaces were being used by the kernel to invoke the module.
%\end{inparaenum}



%\Figref{fig:type_wrapper} shows an example of a type wrapper for the Linux device driver structure. If a pointer to a module function (a future attach point) is discovered, then Granary replaces that pointer with a function-specific \emph{module wrapper}. Granary inspects and modifies arguments to module wrappers in the same way as for kernel wrappers. This allows Granary to discover kernel entry points that will cause instrumentation to detach. Finally, Granary redirects execution to the appropriate kernel or instrumented module function after wrapping has occurred.

%Kernel and module wrappers invoke \emph{type wrappers} to find and wrap pointers to module functions that are directly or indirectly referenced by kernel/module function arguments. A type wrapper is a function that recursively  traverses the in-memory object graph and converts pointers to module code into pointers to wrapped module functions. Type and kernel wrappers are automatically generated at Granary's compile time by scripts that statically analyse the kernel source code. Granary automatically matches any variable in a kernel wrapper to a type wrapper if the base type (absent pointers, specifiers, and qualifiers) of that variable matches the type wrapper's wrapped type. Similarly, Granary automatically generates module wrappers using a combination of compile-time meta-programming and runtime code generation to match type wrappers to the declared arguments of \texttt{C} function pointer types.  Granary's wrapper approach has two benefits: (i) it is more efficient than the trap-based alternative, and (ii) it gives instrumentation tools more information about the executing module (\Figref{sec:reify}).

%Granary automatically generates kernel, module, and type wrappers that cover the entire kernel/module interface (thousands of functions and types).

%Granary automatically applies the correct type wrapper in all cases using \texttt{C++} template meta-programs that operate on kernel type information (\Cref{sec:reify}). 

%Granary automatically applies the correct type wrapper to the arguments of kernel/module wrappers. Automating the wrapping of the kernel/module interface is achieved using 

%Modules expect that the kernel will later invoke these shared functions because it is through these functions that modules extend the functionality of the kernel.

%The novelty
% so that the kernel may later invoke these functions.

%Mode switches occur at well-defined \emph{attach} and \emph{detach} points. Detaching occurs when execution transfers from the code cache to native code, and attaching occurs when execution transfers from native code to the code cache.



%The benefit of mixed-mode execution is that tools can run some code (e.g. kernel code) without overhead by not instrumenting that code. This is valuable because module analysis tools can operate without negatively affecting the rest of the kernel's performance.

%Granary

%The benefit of this feature is that tools have the option to run some code without overhead by not instrumenting that code. The value of this feature is that instrumentation tools can target and instrument specific code without negatively affecting overall system performance.\comment{!!!Qualify me!!!} Granary implements mixed-mode execution by relinquishing control at detach points and regaining control at attach points. This makes Granary \emph{comprehensive}: it controls/instruments all execution of any code of interest.

%TODO TODO TODO: Describe the ``first attach'' by saying how Granary interposes on module initialisation.

%\paragraph{Attaching}\label{sec:attach}
%After Granary bootstraps on the module initialisation process, \emph{attaching} occurs in one of three ways: \begin{enumerate}
%	\item {\bf Implicit attaching:} the kernel returns to instrumented module code in the code cache.
%	\item {\bf Fast attaching:} the kernel invokes a wrapped module function.
%	\item {\bf Slow attaching:} the kernel invokes unwrapped module code. If the kernel executes a module function which was passed to the kernel in a type-unsafe manner, then the processor will raise a fault because Granary uses hardware page protection to prevent module code from being executed. Granary handles these faults by returning execution to the instrumented version of the faulting module code.
%Granary uses memory page protection to mark module code as non-executable, which helps Granary ensure comprehensiveness: if the kernel finds an ``alternate route'' to invoking module code (e.g., some module function is passed to the kernel in a type-unsafe manner and hence is passed unwrapped), then the processor will raise a fault instead of executing that code. Granary handles this fault by returning execution to the instrumented version of the faulting module code.
%\end{enumerate}

%Fast and slow attaching transfer control to instrumented module code. Fast attaching is ``fast'' because the instrumented code address is computed once and emitted as part of the module function wrapper. Slow attaching is ``slow'' because Granary looks up the instrumented address associated with the faulting native address each time the fault occurs.

%\paragraph{Detaching}

%Granary \emph{detaches} when control transfers from instrumented code to native (uninstrumented) code. Detaching occurs in one of two ways: \begin{enumerate}
%	\item {\bf Implicit detaching:} instrumented module code returns to the original kernel, or is interrupted (initial interrupt handling is done by the kernel).
%	\item {\bf Wrapped detaching:} instrumented module code invokes a kernel wrapper, which later transfers control to the kernel.
%\end{enumerate}


%If module code invokes a kernel function then the associated instrumented version of the module code will detach when the call executes. In this case, detaching is explicit because Granary knows that control will transfer to native code. Implicit detaches occur when instrumented module code returns to kernel code or is interrupted. Detaching is implicit in this case because instrumented module code does not know when it will be interrupted or if it was invoked by a kernel function (unless a tool tracks this using policies). 

% invoke a kernel \emph{function wrapper}.
%An explicit detach occurs when the translated version of module
%Instrumented module code implicitly detaches when it is interrupted or returns to kernel code, and explicitly detaches when module code that invokes a kernel function is translated to invoke a kernel \emph{function wrapper}.

%Granary translates kernel function calls in module code into instrumented calls to kernel \emph{function wrappers}. A kernel function wrapper is an automatically generated intermediary function between instrumented modules and the kernel. Kernel function wrappers give Granary and its tools access to the arguments and return values of wrapped functions. Inspecting arguments and return values at the kernel/module boundary is safe because it is a point where modules (regardless of their internal programming) must follow the kernel ABI and agree on data structures.

%Granary uses kernel function wrappers to actively find attach points. Attach points are exposed as function pointers stored in data structures that modules share with the kernel. For example, a device driver module registers itself with the kernel by sharing a pointer to a \texttt{struct device\_driver} object. This object contains several function pointers (e.g. \texttt{probe}, \texttt{remove}) back into the module's code. These function pointers represent attach points: if the kernel invokes one of the function pointers then Granary will take control. Granary finds these attach points and converts then into wrapped module functions. A wrapped module function is like a wrapped kernel functions in that it gives Granary and its tools access to the arguments/return values of an instrumented module function before and after that function is executed.

\section{Policy-Driven Instrumentation}
Granary provides the application the ability to specialise the instrumentation based on execution context. Granary tracks the execution context of a program using technique called \emph{policy-driven instrumentation}. It allows applications to manage different instrumentation policies which can be dynamically switched as and when required based on the context. The behavioral watchpoint framework uses \emph{policy-driven instrumentation} to track the execution context of the module to add watchpoints on the selected objects. The policy-driven instrumentation in the leak detector helps the watchpoint framework track the module entry and exit path and identify the context of memory allocation. The framework adds watchpoint with newly allocated object only if it happens in the module context.

%Other application such as RCU debugger developed using watchpoint framework can use \emph{policy-driven instrumentation} for optimisation by applying the heavyweight watchpoint instrumentation policy only in the read critical section and any execution outside the read critical section uses the null policy. The watched objects which are only allowed to get accessed in read critical section will easily get caught by null instrumentation when accessed outside critical section.

Granary implements policy tracking and switching by encoding policy information in the meta-data and control transfer instructions (CTIs) of basic blocks. The policy information propagates through the control transfer instruction and the targeted basic block either inherits or switches to the new policy as specified.


 %and null instrumentation outside read critical section.



%Leak detector developed over behavioral watchpoint framework uses instrumentation}. It allows applications to manage different instrumentation policies which can be dynamically switched as and when required based on the context. 


%The tool specifying a policy switch on a CTI, instruments the targeted basic block with the specified policy. The CTIs with unspecified policies inherit their policy from containing basic blocks. Granary implements policy tracking and switching by encoding the policy information into the basic block meta-data.

%Behavioral watchpoint framework uses policy switching approach to instrument kernel and module code.


%implement different policy for the kernel and the module code. 


%The policy driven instrumentation provides the behavioral watchpoints the ability to manage code-driven and trap-based instrumentation.


%optimize its performance in-case of 

%its tools the ability to dynamically switch the policy used to instrument the module code. This provides the behavioral watchpoint ability to 

%A natural extension of mixed-mode execution is to give Granary tools the ability to dynamically switch the policy used to instrument code. Instrumenting only module code allows Granary to specialise the execution of native code. In the same way, policy switching allows tools to specialise the execution of instrumented code. In fact, optimising the performance of an early Granary tool was the original motivation for policy switching.

%We developed a Granary tool that detects several Read-Copy-Update (RCU) API misuses in module code. Our tool focused on read-side critical sections (delimited by calls to \texttt{rcu\_read\_lock} and \texttt{rcu\_read\_unlock} in the code), however, most code executes outside of read-side critical sections. As an optimisation, we wanted our heavyweight API-checking instrumentation to apply only when the code was executing within a read-side critical section. Implementing this optimisation was challenging because each basic block was only translated once, and we had no way to know whether or not the heavyweight instrumentation should be applied to it. Knowing the state (within or outside a read-side critical section) at translation time was not sufficient, since the same translated block could later be executed in the opposite context. That is, code executing \emph{within} a read-side critical section may have originally been translated while executing \emph{outside} of a read-side critical section, and would thus omit the heavyweight API-checking instrumentation. This omission could cause our tool to miss bugs (i.e., it would not be comprehensive) when the basic block executes within a read-side critical section.

%Implementing this optimisation was challenging because we did not have a reliable way to know whether or not some code being translated was or would execute within a read-side critical section. That is, instrumented module code executing within a read-side critical section may have originally been translated while executing outside of a read-side critical section. If that lightweight-instrumented code was later executed within a read-side critical section, then our bug detection scheme would not have been comprehensive. 

%To implement this optimisation, Granary enables tailoring instrumentation to the context in which the instrumented code will execute. To do so, Granary allows different versions of the same module code to co-exist within Granary's code cache. That is, a different version of each of a module's basic blocks exists in Granary's code cache  for each encountered execution context. In the case of our RCU checker tool, there were two execution contexts: within and outside of a read-side critical section. If the same module basic block is  executed in the two contexts, then Granary's code cache would contain two different instrumented versions of that basic block. The way that Granary distinguishes between different execution contexts is with \emph{instrumentation policies}. 

%An instrumentation policy is both a name for an execution context, as well as a function that decides how to instrument basic blocks that will execute within that context. All tools define an initial policy that Granary uses to instrument module code. Tools are not limited to one policy though: any policy can declare a policy switch that will take effect when a selected control-transferring instruction (CTI) is executed. For example, our RCU tool invokes a policy switch from policy $P_{\mathit{null}}$ to policy $P_{\mathit{read\_critical}}$ when $P_{\mathit{null}}$'s instrumentation function observes a \texttt{call} instruction to the \texttt{rcu\_read\_lock} Linux kernel function.

%Because policies name an execution context, they also represent states in a finite state machine. That is, a module's execution is in the state named by a policy if the code executing was instrumented by that policy. A state transition occurs when control transfers from code instrumented by one policy to code instrumented by another policy. A limitation with this approach is that a single state does not encode the sequence of previous states that led to execution being in the current state. For example, RCU permits nested read-side critical sections. If two read-side critical sections are nested then switching from $P_{\mathit{read\_critical}}$ to $P_{\mathit{null}}$ on the first \texttt{call} to \texttt{rcu\_read\_unlock} meant that our tool would lose track of being in the context of the outer read-side critical section. We solved this limitation by observing that, in most cases, function returns are natural policy reverting points. This is because the runtime call stack encodes both the context in which the current code is executing, as well as the continuation of the current executing code.

%The effect of a tool specifying a policy switch on a CTI is that the basic block(s) targeted by that CTI will be instrumented according to the specified policy. CTIs with unspecified policies inherit their policies from their containing basic blocks. As hinted at above, \texttt{ret} instructions cannot explicitly switch policies, which allows a function instrumented by a different policy than its caller to return to the caller's context (i.e., policy). The asymmetry between \texttt{call}s and \texttt{ret}s is intentional: \texttt{call}s place contextual breadcrumbs (in the form of return addresses) on the runtime call stack, and \texttt{ret}s read these breadcrumbs to return to a previous context. Under this lens, the instruction pointer tracks our current policy, and return addresses form a stack of previous policies. Policy switches behave similarly to state transitions in a pushdown automaton; \texttt{call} instructions push a new state onto the stack for each function, \texttt{ret} instructions pop the current function's state from the stack, and other CTIs induce state transitions within the current function by altering control flow.


%Here is why CALL is special: because it places return addresses (breadcrumbs) on the runtime call stack. Under this lens, the instruction pointer maintains our current state, and return addresses form a stack of previous states.

%This is similar to the behaviour of a pushdown automaton, and can be viewed from a language theoretic perspective. A CALL is like a push, that pushes a new state on the stack. A RET is like a pop/reduce, where we accept the execution of some function. All other CTIs are like shifts, where the internal state transitions within the function, and independent of the states of all of our callers. In summary, policy switching can be seen as language acceptance, where policies accept/reject an execution iff that execution can be generated by a context-free grammar.

%Granary implements policy tracking and switching by encoding policy information into the meta-data and CTIs of basic blocks. If a policy switch is not specified on an instrumented CTI then that CTI inherits the policy used to instrument the basic block containing the CTI. When an instrumented CTI executes for the first time, it yields control to Granary with the CTI target and policy information as inputs. Granary decodes and instruments the targeted instructions according to the input policy information. Because every non-\texttt{ret} CTI encodes policy information, and because Granary's translation mechanism depends only on CTI policy and target information, Granary is able to ensure that policy information is never lost or corrupted, even in the face of concurrent executions of the same module code, arbitrary pre-emption, and arbitrary resumption.

% Our approach makes tools that use policies to track states of a module's execution resilient against arbitrary pre-emption and resumption because once cached, the policy-switching behaviour of a basic block cannot be accidentally corrupted or lost (e.g. due to concurrency bugs). 

%One drawback of Granary's policy implementation is code cache bloat. We feel that this is a reasonable tradeoff because \begin{inparaenum}[i)]
%	\item tool authors are not required to use more than one policy if bloat is a concern; and
%	\item things that are challenging to do with only one policy are often simpler to do with multiple coordinating policies.
%\end{inparaenum} 

%One example of a tool that uses policy switching is Granary's CFG tool, which dynamically constructs runtime inter- and intra-procedural control-flow graphs (CFGs). A single policy approach for call graph construction might add edges to the call graph only at every \texttt{call} site. However, this approach is insufficient in the face of mixed-mode execution. If an instrumented function $F$ is only invoked by a native function (which contains no instrumentation), and $F$ contains no function calls, then $F$ will not appear as a root node in the call graph. A two-policy solution easily solves the missing root problem by instrumenting both function call sites as well as function entrypoints. The CFG tool distinguishes between the first execution of a function's first basic block ($P_{\mathit{call\_entry}}$), and all other basic blocks executed within the function, including later executions of the first basic block ($P_{\mathit{after\_entry}}$). Function call sites are instrumented to set up the source node of an edge in the call graph. On entry to a function, we identify the current function as either a sink node connected to a source node (instrumented call), or as a root node if no source is present (native call). The distinction between entrypoints and non-entrypoints is achieved with minor bloat: the first basic block appears twice in Granary's code cache, but instrumented by two different policies, as shown in \Figref{fig:policy_switching}.

\section{Reifying Instrumentation}
Granary uses a technique called \emph{reifying instrumentation} to provide the benefits of high-level static analysis information to dynamic instrumentation tools. Reifying instrumentation bootstraps on Granary's mixed-mode execution approach, which exposes static type information to instrumentation tools. The type information can be used by the behavioral watchpoint framework to identify and add context specific information with the watched objects. %The ability to associate the context specific information with each watched objects enables the watchpoint framework develop different debugging applications.
The behavioral watchpoint framework actively uses the context-specific information associated with the watched objects to create various analysis tools such as selective memory shadowing for generating the models of typical module behavior. 

The high-level static information present at the wrapper serves two roles in the tool. First, the type wrappers are used to assign type-specific IDs to module-allocated memory that is shared across the module/kernel interface. This type-specific ID assignment is critical because it allows us to match memory reads and writes to specific kernel data structure fields. Second, the kernel and module function wrappers are used to generate call graphs of a module's execution. This call graph models module behaviour (according to the kernel) because we label module code nodes with kernel data structure and function pointer field names (derived from module wrappers). This labelling allows us to generalise across similar modules. For example, code reached by calling the \texttt{ext4\_mount} and \texttt{btrfs\_mount} functions from the \texttt{ext4} and \texttt{btrfs} modules, respectively, are both labelled as \texttt{file\_system\_type::mount},
%. These functions are labeled in this way
 because these function addresses are stored (and later replaced by module wrappers) in the \texttt{mount} field of a \texttt{file\_system\_type} data structure. %The combined records from multiple ``trusted'' modules of the same class (e.g., mature, open-source file systems) will model the behaviour of typical kernel modules. We hope that these models will help us build tools that classify and identify spurious module behaviour. 


These three features make Granary unique among DBT-systems. We choose Granary as the underlying DBT system, this is because of its ability to integrate the high-level static analysis informations with low-level instruction manipulation and support the context-aware runtime code specialisation. These are important to implement different features of behavioral watchpoints. In next chapter, we will discusses the design, implementation and the different features enabled by the behavioral watchpoint that helps in developing program analysis tools. 



%and implementation of behavioral watchpoints.



%to implement behavioral watchpoints. This is because Granary makes it easy to create tools by supporting context-aware runtime code specialisation and making high with high-level static analysis informations with low-level instruction manipulations


%Granary is unique among DBT systems because it provides three important features: i) mixed-mode execution, ii) policy-driven instrumentation, and iii) reifying instrumentation. The \emph{mixed-mode execution} allows the watchpoint framework to switch the execution between instrumented and native mode implicitly or with the wrapper interface. Granary achieves this by substituting the execution of a function with a \emph{wrapped} version of itself. A wrapped function has the same type specification as its unwrapped counterpart and can freely modify its arguments and return value. Granary can wrap some module functions in this way, even if the module source code is unavailable.


%These features makes Granary 


%makes it easy to create tools by supporting context-aware runtime code specialisation and making high with high-level static analysis informations with low-level instruction manipulations.  

%We compress these call graphs by treating internal module function calls as 

%The call graphs we generate are compressed to view internal module activity as not containing function calls. The compressed graphs remain meaningful because we label module code according to the entrypoints

%This call graph is compress

% from the perspective of the kernel because we name the entrypoints into the module

%, while we do not know the names of binary module functions, we do know the kernel names for those functions because those are the names of function pointer fields in kernel data structures.

%Together, the recorded information tells us when and where specific parts of kernel data structures are accessed and modified. Finally, we combine the information recorded from executing multiple ``trusted'' modules (e.g. mature, open-source file systems) and construct models of typical module behaviour. We hope that these models will help us to automatically generate new tools that identify spurious module behaviour.

%Existing program analysis systems fall into one of three categories:
%\begin{enumerate}
%	\item Binary analysis tools. Existing tools give low-level access to instructions and possibly memory but don't give ``big-picture'' information available source code analysis tools \cite{DRK,DynamoRIO,Pin,PinOS,QEMU,Valgrind}.
%	\item Source code analysis tools. Existing tools give high-level access to program semantics but make it challenging to reason about scheduling, interrupts, shared memory, and aliasing [TODO: cite Sparse, Smatch].
%	\item Mixed source/binary analysis tools. Existing tools give high- and low-level access to program information, but require changes to the compilation toolchain and sometimes program source code \cite{NaCl,AddressSanitizer,ThreadSanitizer}.
%\end{enumerate}



% Granary extracts type and function declarations from the Linux kernel source code and exposes that information to tool developers. Information extracted with static analysis is available using either \texttt{C++} template meta-programs or \texttt{Python} scripts that operate on kernel type graphs. For example, we use extracted static type information to generate hooks that invoke tool-specific functions on all memory writes to a specific kernel data structure field. We can use this tool to precisely detect if/when a module violates a kernel data structure invariant.
%
%\begin{figure}[t]
%\begin{lstlisting}[language=C,basicstyle=\footnotesize\ttfamily]
%// Invariant: rtc_fops->ioctl == &rtc_ioctl
%WATCH_WRITE(struct file_operations, ioctl, {
%  if(&rtc_fops  == base_address
%  && &rtc_ioctl != ioctl) {
%    // potential attack: prevent an anti-
%    // virus scan from being scheduled!
%  }
%})
%\end{lstlisting}
%\ORIGcaption{\label{fig:field_invariant_check}This code generates a function that is automatically invoked every time memory with the type \texttt{struct file\_operations} is accessed. The generated function checks invariant 1(h) from \cite{GibraltarKernelInvariants}. The invariant checked prevents a (potential) kernel rootkit from installing its own \texttt{ioctl} handler into the Real-Time Clock. Anti-virus programs depend on this built-in \texttt{ioctl} handler to periodically schedule virus scans. Replacing this handler can prevent such scans from being scheduled, thus allowing the rootkit to go undetected.}
%\end{figure}


%generates another tool that detects Linux kernel invariant violations. In particular, our tool interposed on memory accesses at the granularity of Linux kernel data structure fields, and checked that values being written to those fields maintained data-structure-specific invariants }.


%Another use of Granary's static analysis information is meta-tools: tools that generate tools based off of static analysis information.

%Tools can also use meta-programs that operate on the static analysis information to automatically generate new tools 

%For example, 

%We say that static type information is \emph{reified} because Granary re-introduces it into module binaries by using it to discover attach and detach points. Type information reified by Granary can guide runtime instrumentation decisions. For example, a tool can switch the instrumentation policy based on memory accesses to data of a particular type or based on the usage of a particular module/kernel interface. Tools can also dynamically learn the runtime types of module-allocated objects by observing pointers to those objects as they cross the module/kernel interface.

%Granary \emph{reifies} static type information by using it to guide attaching and detaching, as well as by allowing tools to base runtime instrumentation decisions 
%
%re-introducing it into ``typeless'' module binaries.  Granary understands the module/kernel boundary using attach (kernel wrappers) and detach (module wrappers) points.
%
%at the module/kernel boundary
%
%We call the technique of using static analysis information in Granary ``reifying instrumentation'' because:
%\begin{enumerate}
%	\item Static type information is not present in module binaries. Granary re-introduces type information into ``typeless'' module binaries because modules use kernel functions and data structures to interact with the kernel.
%	\item Static program information can guide runtime instrumentation decisions. For example, the policy used to instrument code can be changed based on:
%	\begin{enumerate}
%		\item A memory access to data of a particular type.
%		\item The usage of a particular interface (kernel function or function pointer field within a kernel data structure).
%		\item The presence of an object of a particular type being passed as an argument to a module function.
%	\end{enumerate}
%	\item Runtime type information can be dynamically learned. For example, if a module allocates some memory then that memory is initially typeless. However, if a Granary tool observes that the allocated object is reachable from an argument to a module or kernel function wrapper then a type can be assigned to that memory.
%\end{enumerate}

%We are actively developing a tool that uses reifying instrumentation to create models of module behaviour. 

%By combining this information from multiple ``trusted'' modules (e.g. mature, open-source file systems), we hope to be able to create instrumentation that discovers spurious module behaviour 

%For example, we can use the static information available to Granary to create a tool that generates code that, when executed, checks that it is 

%kernel and module wrappers can be combined with policy-switching to enforce some API usage integrity constraints. For example, policy switching can be used to accept or reject an execution of module code by observ

%most useful at mode-switching boundaries, where 

%Static program information is available to Granary tools in the form of kernel types and function declarations. Tools can operate on this information with meta-programs, as well as observe 

%Tools can use this information to interface with the kernel or to 

%We use this information in several novel ways:
%\begin{enumerate}
%	\item 
%\end{enumerate}

%Tools can use meta-programs to operate on this information and generate code (at the tool's compile time) that coordinates with the tool's dynamic analyses in order to learn more about module code. 

%This technique, which we call ``reifying instrumentation'', is distinct from typical dynamic analysis
%We call the technique of mixing static program information into a DBT system ``reifying instrumentation'' because it takes abstract information (e.g. type information) which is absent from module binaries and re-introduces it as actionable data. This data is actionable insofar as the 

%Granary exposes static program information to instrumentation tools in the form of 
%Granary tools can use static program information 
%Reifying instrumentation is the process of using static program information known at mode-switch boundaries to guide the application of different instrumentation policies. The key insight of reifying instrumentation is that the execution of attach and detach points (kernel wrappers) give clues as to how modules and the kernel are interacting.
%Reifying instrumentation allows tools to inspect and manipulate a portion of program memory at attach (module wrappers) and detach points and in a well-defined way. 
%This is useful because it helps the instrumentation system learn more about the execution of an otherwise opaque binary. The value of this feature is that users can create low-level instrumentation tools that operate on programs in a high-level way. 
%Granary uses a technique that we call reifying instrumentation in order to 
%The key insight of reifying instrumentation is that even arbitrary binaries must follow conventions and APIs to correctly interact with other programs.
%\section{Environment}\label{sec:env}
%\subsection{Interrupts and Exceptions}\label{sec:interrupts}


%Because of mixed-mode execution, a given function's caller might have been executing natively, therefore we cannot depend on 

%needs to distinguish between the first execution of a function's first basic block and later executions of that basic block (e.g. because of backward branches within the function).

%Granary depends on these inputs alone as a means of ensuring consistency.
%: Granary cannot ``lose track'' of state concerning the execution of some code because the code itself maintains that state.  This enables arbitrary pre-emption and resumption of instrumented code without negatively affecting how as-of-yet uninstrumented code will be instrumented. The value of this approach is that it simplifies the process of creating instrumentation tools that run in OS kernels.
%Our experience with policy switching has been that they are a robust way of tracking state about the execution of a module. This is especially true in the
%For example, we created a tool that uses policies to implement different weights of instrumentation. Unfortunately, execution got ``stuck'' in a heavyweight policy after the first policy switch from light to heavyweight. We also didn't want to arbitrarily switch from a heavyweight to a lightweight policy, lest the switch occur too early. 
%function returns were the best indicator of when to revert to a previous policy.
%the best indicator of when to revert to a previous policy/context was
%because while a policy names an execution context but made no 
%, and contexts
%While designing module analysis tools, we realised that it is valuable to be able to revert to a previous state. For example, 

%Switching policies based on CTIs fits well with Granary's JIT-based translation mechanism for two reasons. First, a tool cannot be certain about when a given CTI will first be executed. For example, Granary translates a single conditional branch into two CTIs: one conditional branch, and a fall-through \texttt{jmp} to the next basic block. If the tested condition is always true then the fall-through basic block might never be instrumented. However, if a failure of the tested condition indicates a context switching scenario, then 

%For example, the fall-through basic block after a conditional branch may never be executed if the tested condition is always true. 

%Because of this, the basic block targeted by the CTI that connects the testing basic block to the fall-through basic block

%Our experience with implementing policy swithc



%

%; however, most Granary tools define more than one interacting policies.

% By default, all module code is instrumented by the initial policy. However, if a tool wants to declare an execution context switch (e.g. entering into a read-side critical section) then the active


%However, any policy (including the initial policy) may declare that a policy switch will occur at a control-flow transferring instruction (CTI). The effect of declaring a policy switch at a CTI is that 

%a tool tells Granary to switch policies. A policy switch can occur at control-flow instructions.

% is a function that decides how to instrument a basic block of module code that will execute within the execution context named by that policy.
%An instrumentation policy is a name that a tool gives to an execution context. A policy decides how to instrument a basic block of module code that is executing within 

%for each encountered execution context , a new version of the basic block tailored to that context.
% is handled by a different \emph{instrumentation policy}.
%Granary solves the problem of context-aware instrumentation using a technique that we call policy-driven instrumentation. An instrumentation 
%The underlying problem that we solved was to change the behaviour of instrumentation based on the context in which code executes.
%The underlying problem that we needed to solve in order to implement our RCU checking optimisation was: \begin{inparaenum}
%was that a basic block should have some notion of the context in which its executing.

%TODOs \begin{itemize}
%	\item It turned out that part of the problem we were trying to solve was tracking/propagating state, and so policies and switching was a really good mechanism of doing this.
%	\item New paragraph about policy info being encoded in basic blocks, and starting to introduce policy state, etc.
%	\item Perhaps use the RCU example as a way of also motivating the SIMD saving / restoring?
%\end{itemize}

%translated 
%Recall that Granary translates basic blocks on demand.
%At a high level, an instrumentation policy is a function that decides how to instrument decoded instructions before they are encoded and packaged into a basic blocks in Granary's code cache. A policy switch is declared when one policy marks the target of a CTI as being instrumented by another policy. The actual switch occurs when code is executed: 
% occur across control-transfer instructions.
%Granary defines an initial policy that Granary uses to instrument module code. However, the initial policy 
%Despite being one of Granary's most dynamic features, policy switching is implemented in a ``static'' way. Policy information (for documenting the current policy and for switching policies) is embedded directly into basic blocks and control-transferring instructions. Thus, the policy of a newly emitted basic block and the policies of any basic blocks translated as a result of executing CTIs within the new basic block are fixed.
%Granary encodes policy information directly into basic block meta-data and the control-transferring instructions (CTIs) of basic blocks. Thus, 
%While designing Granary's dynamic policy switching mechanism, it quickly became clear that a static approach was needed to 
%When an instrumented CTI executes for the first time, it yields control to Granary with the CTI target and policy information as inputs. Granary decodes and instruments the targeted instructions according to the input policy information. 
% Granary depends on these inputs alone as a means of ensuring consistency: Granary cannot ``lose track'' of state concerning the execution of some code because the code itself maintains that state.  This enables arbitrary pre-emption and resumption of instrumented code without negatively affecting how as-of-yet uninstrumented code will be instrumented. The value of this approach is that it simplifies the process of creating instrumentation tools that run in OS kernels.
%Like mode-switching, Granary also allows tools to switch how code itself is instrumented. 
%As Granary was being developed, it became clear that 
%Our original goal with Granary was to instrument only Linux kernel modules. This was a natural extension from DRK: 
%When developing new module instrumentation tools, a common thought 



%New module analysis tools are created by implementing one or more interacting instrumentation policies. Module analysis tools use policies to track state (called \emph{policy properties}) and decide how to instrument code.

%Policies also serve a broader role in Granary itself. Granary maintains internal policy properties to optimise its performance and to track certain kinds of control flow. One example of a policy property used by Granary to optimise its user space performance is SIMD register tracking. When Granary detects the usage of a SIMD register, it sets the associated property. This property is inherited through the call chain, and informs Granary on whether or not the SIMD registers must be saved/restored when instrumented code yields to Granary. We say that an execution of a function $F$ is in the context of a usage of a SIMD register when the SIMD property is set. If $F$ is later executed by instrumented code where the SIMD property is not set, then a second instrumented version of $F$ (absent the SIMD property) will be stored in the code cache.

%A developer prototyping a module analysis tool that uses multiple policies will automatically benefit from Granary's SIMD-tracking optimisation. Properties apply equally to all policies, and are inherited if/when a control-flow transfer effects a policy switch. However, not every control-flow transferring instruction (CTI) can explicitly change the policy used to instrument code: policies and their properties are not inherited across function returns. The motivation for this asymmetry is that conditions (e.g. SIMD register usage) present in a function $F$ might not be present in $F$'s caller. Because of this, function returns act as a natural mechanism for restoring instrumentation to a previous context. For example, Granary's SIMD register tracking is an effective optimisation because it limits the scope of saving/restoring the SIMD registers to only those yields performed in the context of a SIMD register, and not to all yields performed after the first usage of a SIMD register.

%.... set properties / properties naturally revert / etc. explain why no inheritance through RETs.

%This example of policy properties highlights some of their features: properties are inherited through control-flow instructions, even when policies themselves might change.

%Instrumentation policies are used to create new instrumentation tools and track state for those tools. An instrumentation policy is a set of functions that operate on a sequence of instructions ending in a non-call control-transfer instruction (CTI), called a basic block. The functions of a policy are responsible for adding instrumentation to a basic block and deciding what policy to apply to subsequent basic blocks. Granary is responsible for tracking and propagating any state associated with policies, called \emph{policy properties}.
%	
%	%State is tracked and propagated through the use of policy properties.
%	
%	%The functions of an instrumentation policy can arbitrarily manipulate the instructions of an instrumented program, as well as decide the ``next'' policy should be
%	
%	%Instrumentation policies are the means by which users of Granary can create instrumentation tools, as well as being the preferred mechanism for tracking and propagating state concerning the system's awareness of the code being instrumented.
%	
%	%Instrumentation policies in Granary serve two main purposes:
%	%\begin{inparaenum}[i)]
%	%	\item deciding how to instrument a sequence of instructions; and
%	%	\item tracking and propagating state/context using \emph{policy properties}.
%	%\end{inparaenum}

%\subsection{Creating Tools with Policies}
%
%Tool developers must implement three functions for each policy: \begin{enumerate}
%	\item $F_{module}$ instruments a basic block of module code.
%	\item $F_{kernel}$ instruments a basic block of kernel code.
%	\item $F_{interrupt}$ handles an interrupt in instrumented code.
%\end{enumerate}
%
%The majority of tools will focus on implementing $F_{module}$; however, we have found $F_{kernel}$ useful when implementing \emph{data-driven instrumentation} and $F_{interupt}$ useful when implementing multiple weights of instrumentation in response to interrupt behaviour. 

%Granary provides a framework for fine-grained memory access instrumentation, called \emph{behavioural watchpoints}. Behavioural watchpoints-based tools expose tainted memory addresses to instrumented programs. If a tainted address is used to access memory then the processor raises a fault. Instead of instrumenting all code in a way that guards against such faults ($P_{\mathit{watchpoints}}$), Granary defaults to instrumenting basic blocks using $P_{\mathit{null}}$. However, when a fault is raised, Granary prevents future faults from occurring within the same basic block by patching the $P_{\mathit{null}}$-instrumented basic block to re-route control to a $P_{\mathit{watchpoints}}$-instrumented basic block.

%For example, tools built with Granary's behavioural watchpoints framework expose tainted memory addresses to instrumented modules. Modules and the kernel freely share data, making it almost inevitable for  tainted addresses to ``leak'' into the kernel. If the kernel attempts to access the memory referenced by a tainted address then the processor will raise a fault. We handle this fault by applying $F_{kernel}$ to instrument the faulting kernel code using a policy that protects against such faults ($P_{\mathit{watchpoints}}$). $F_{interupt}$ is also used to optimise the execution of tools using behavioural watchpoints by initially assuming that code will not dereference a tainted address ($P_{\mathit{null}}$) and upgrading to $P_{\mathit{watchpoints}}$ if a fault on a tainted address occurs within a $P_{\mathit{null}}$-instrumented basic block.

% instrument as much or as little of the kernel as they want in response to this fault.
%Instrumentation policies expose three functions: one to instrument module code, one to instrument kernel code, and one to handle an interrupt in instrumented code.


%$F_{module}$ and $F_{kernel}$ can arbitrarily manipulate instructions and policy properties before they are packaged into basic blocks. These functions decide what the ``next'' policy should be for each CTI within the basic block. For example, if $P_{\mathit{call\_entry}}$'s $F_{module}$ sets the policy of a CTI in the basic block to policy $P_{\mathit{after\_entry}}$, then any module code targeted by the changed CTI will be translated and instrumented by $P_{\mathit{after\_entry}}$'s function $F_{module}$ (\Cref{fig:policy_switching}). 

%Because Granary depends on DynamoRIO's instruction encoder/decoder, the full range of DynamoRIO instruction/operand manipulation functions can be applied to instructions within a basic block.

%\subsection{Managing State with Policies}

%Policies encode state in the form of properties. A policy property describes an aspect of the environment in which the instructions of a basic block execute. Properties are tested, set, and unset by Granary and tool-specific policies over the course of decoding, instrumenting, and packaging instructions into basic blocks. By default, properties are propagated across all control-flow transfers except for return instructions. Property propagation through function call instructions enables inheritance of contextual information through the function call chain. The lack of propagation through function returns enables execution to return to a previous context.

%Granary encodes policy information into the meta-data and CTIs of basic blocks. When an instrumented CTI executes for the first time, it yields control to Granary with the CTI target and policy information as inputs. Granary decodes and instruments the targeted instructions according to the input policy information. Granary depends on these inputs alone as a means of ensuring consistency: Granary cannot ``lose track'' of state concerning the execution of some code because the code itself maintains that state.  This enables arbitrary pre-emption and resumption of instrumented code without negatively affecting how as-of-yet uninstrumented code will be instrumented. The value of this approach is that it simplifies the process of creating instrumentation tools that run in OS kernels.

%Granary's approach to managing state was motivated by our experience of trying to analyse modules with DRK. DRK maintains control over the execution of instrumented code by tracking what code is executing on each CPU. However, maintaining the consistency of this state is challenging: interrupts and exceptions introduce re-entrancy issues that are solved on a case-by-case basis. The complexities of managing the existing state increased when we modified DRK to only instrument modules and not the kernel. We found that our modified DRK sometimes ``got lost'' because of the interaction between interrupt handling, state management, and patching of translated code.

%We found that DRK sometimes ``got lost''  when analysing modules because the mechanism 
%because of the interaction of interrupt-handling, state-management, and patching of translated code.
%A property is set when Granary detects the usage of a SIMD register. This property is inherited through through the call chain.
%  The latter property is used by Granary to decide how to handle interrupts within instrumented kernel code.
%Instrumented code can be arbitrarily pre-empted and resumed without concern.
%instrumented code yields control to Granary to build further basic blocks
%Granary was designed to operate in a multi-threaded, multi-core, pre-emptive kernel.
%Policy properties are encoded into the control-transfer instructions and meta-data of each basic block. This ensures that once emitted, the policy information of a basic block is immutable. 
%This is beneficial because Granary behaves in a purely functional way with respect to policies: 
%to be \emph{pure} with respect to policies: Granary's behaviour is fully-determined by 
%Policy properties are eventually immutable because they are directly encoded into the instructions and meta-data once 
%Policy properties are eventually immutable because once instructions have been packaged into a basic block, the properties that determined how those instructions, as well as any instructions targeted by control-transfer instructions within the basic block, were translated/instrumented never changes. 
%Immutability has the benefit of simplifying consistency when running in 
%that are tested, set, and unset by Granary and its policies during basic block creation.
%\paragraph{Policy behaviours}
%\paragraph{Policy conversions} can occur at any control-transfer instruction, with the exception of return instructions.
%If instrumentation purposefully exposes addresses that generate faults when accessed, then a policy interrupt handler can patch the original basic block to re-route control to a version of the original basic basic block that will guard itself against faults on memory accesses. This technique is used by Granary to optimise applications using \emph{behavioural watchpoints} to do fine-grained memory access instrumentation.
% TODO interrupts
%An example of how multiple policies are 
%Changing the policy during execution is useful for 
%\subsection{Clients}
%An instrumentation policy is a mechanism for deciding how to instrument a sequence of instructions, as well as how to instrument instructions targeted by any control-flow transferring instructions within the sequence.
%is a mechanism for maintaining and propagating immutable state that is used to decide how to instrument a sequence of instructions.
%is a mechanism for deciding how to instrument a sequence of instructions based on
% maintaining and propagating immutable state within a DBT system.
%and propagating state, as well as deciding how to instrument a sequence of instructions.
%\section{Managing State}\label{sec:state}
%Granary manages state using three mechanisms: shared data, CPU-private data, and instrumentation policies. 
%\paragraph{Shared data:} Granary maintains a centralised cache of all instrumented code, called the \emph{code cache}. The code cache is a data store that maps native (uninstrumented) code addresses to sequences of instrumented instructions, stored in the form of \emph{basic blocks} and their meta-data. 
%In Granary, a basic block is a maximal sequence of instructions that end in a non-function-call control-flow instruction. The inclusion of function calls within basic blocks is deliberate: Granary operates using a relaxed transparency model, and including function calls is a natural optimisation opportunity given this model. Addresses into the code cache are ``leaked'' to instrumented programs in the form of return addresses saved on the run-time call stack. Code cache addresses also leak to native code when mixed-mode execution is employed. Our experience with kernel instrumentation is that the kernel is not sensitive to such leaks. We have not yet encountered 
%\paragraph{CPU-private data:} Each core maintains a private mapping of native code addresses to code cache code addresses. This mapping
%When a new basic block is translated and stored in the global code cache, the mapping between the basic block and the nativ
%\paragraph{Instrumentation policies:}


%We intend to extend Granary to instrument all kernel code. 

%Typical kernel modules are written in C and sometimes mixed with assembly. There is good motivation for writing modules in C: the Linux kernel has many useful macros and inline functions that aren't directly available to assembly. To the best of our knowledge, C compilers do no

%\begin{enumerate}
%	\item {\bf Function return addresses:} Instrumented module functions and kernel functions can 
%	\item {\bf Interrupt return address:}
%	\item {\bf Data structure function pointers:}
%	\item {\bf Stack pointer:} 
%\end{enumerate}


%values of a function's return address or function pointer 
% function return addresses or 
%A detach point is any kernel code called by instrumented module code. An attach point is module code that is 
%A detach point is any kernel function and an attach point is any module code executed by the kernel. Granary statically analyses the kernel source code to learn about detach points and their specifications. Granary dynamically ``learns'' about attach points by observing module code addresses as they cross the module/kernel interface. A typed attach point is a
% in the form of shared function pointers. Granary detects shared function pointers by recursively inspecting the data passed over the kernel/module interface using type wrappers (\Cref{fig:type_wrapper}).

%\section{Watchpoint}
%Watchpoint is an important debugging facility that helps users identify data corruption bugs. It is valuable because they enable a data-oriented debugging strategy in addition to control-flow-oriented strategy~\cite{Copperman:1995:PMW:199818.199852, Keppel93fastdata}. Two kind of watchpoint exist : 1) Hardware-based Watchpoints, 2) Software based watchpoints
%\subsection{Hardware Watchpoint}
%The most efficient implementation of watchpoints requires hardware support. It is becoming more common for machines to provide hardware support for watchpoints. While hardware-based watchpoints are efficient, they are limited in numbers and size.
%\subsection{Software Watchpoint}
%Watchpoints can be implemented in software using one of the following mechanism:
%\begin{itemize}
%	\item virtual memory
%	\item trap-patching
%	\item code patching
%\end{itemize}


%With this background on Granary, it is time to focus on the design and implementation of the behavioral watchpoints.  %It just ends rather abruptly 