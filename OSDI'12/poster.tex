\documentclass[10pt,preprint,nocopyrightspace]{sigplanconf}
\usepackage{amsmath,epsfig,subfigure,multirow}

\usepackage{graphicx}
\usepackage{refstyle}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{framed}
\usepackage{lipsum}
\usepackage{multicol}
\usepackage[english]{babel}
\usepackage{numprint}
\usepackage[dvipsnames]{color}
\usepackage{footmisc}
\usepackage{relsize}
\definecolor{shadecolor}{RGB}{250,250,250}

\renewcommand\footnotelayout{\larger}
\long\def\symbolfootnote[#1]#2{\begingroup%
\def\thefootnote{\fnsymbol{footnote}}\footnote[#1]{#2}\endgroup}

\begin{document}

%\conferenceinfo{OSDI'12}{Feb. 23, Shenzhen.} 
%\copyrightyear{2012} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.


\title{Granary: Comprehensive Kernel Module Instrumentation}
\subtitle{University of Toronto}

\authorinfo{Peter Goodman*\and Angela Demke Brown}
           {\{pag, demke\}@cs.toronto.edu}

\authorinfo{Akshay Kumar*\and Ashvin Goel}
           {\{akshayk, ashvin \}@eecg.toronto.edu}

\maketitle

\renewcommand{\secref}[1]{\S\ref{sec:#1}}

% until we find a name for our system, the following commands should suffice :-)
\newcommand{\sysname}{Granary}
\newcommand{\Sysname}{Granary}


\newcommand{\note}[1]{}

Kernel modules extend the functionality of operating systems (OSes). Modules are used to support new devices (e.g. network and graphics cards) and provide new features (e.g. file systems). The kernel and its modules execute in a complex and dynamic environment. Understanding how modules behave in and affect this environment is important. However, analyzing module behavior is challenging. Static analysis of module source code is difficult because of the tight interaction between modules and the kernel. Some modules, however, are only distributed in a binary format, which makes static analysis intractable.

We created {\Sysname} to address the challenges of module analysis. {\Sysname} is a framework that efficiently instruments \emph{arbitrary}, binary Linux kernel modules. {\Sysname} uses dynamic binary translation to dynamically rewrite and comprehensively instrument kernel modules. Our extensive use of compile-time meta-programming enables efficient, dynamic analyses that are driven by static kernel type information. 

While designing {\sysname}, we identified four goals for practical module analysis: i) comprehensively analyze \emph{all} modules; ii) impose no performance overheads on non-module kernel code; iii) require no changes to modules and minimal changes to the kernel, and; iv) be easily portable between different hardware and kernel versions. Prior research based on source code analysis and annotations \cite{YMao2011} fails to meet goals (i) and (iii), while work based on special hardware features or virtualization \cite{Xiong2011} fails to meet goals (i) and (iv), and work based on whole-OS or -system instrumentation/emulation \cite{Feiner2012} fails to meet goal (ii).

{\Sysname} meets all four stated goals:
\begin{enumerate}[i)]
	\item {\Sysname} is comprehensive because it controls and instruments the execution of all module code. {\Sysname} maintains control by ensuring that normal module code is never executed. Instead, only decoded and translated module code is executed. Translated module code contains instrumentation and always yields control back to {\sysname}. All modules can be instrumented in this way because dynamic binary translation operates on binaries and does not depend on any hardware features.
	\item Kernel code runs without overhead because {\sysname} relinquishes its control whenever an instrumented module executes kernel code. {\Sysname} implements a novel technique for re-gaining control when kernel code attempts to execute module code. Each time some instrumented module code invokes a kernel function, each of that function's arguments are \emph{wrapped}. Argument wrappers are type- and function-specific, and ensure that potential module entry points (e.g. module function pointers) are replaced with behaviorally-equivalent values that first yield control to {\sysname}.
	\item We have changed less than 100 LOC in the Linux kernel in order to support {\sysname}.
	\item {\Sysname}'s wrapping mechanism is portable across different kernel versions because the majority of wrappers are automatically generated by a GCC plugin and several meta-programs.
\end{enumerate}



%{\Sysname} maintains control by executing only translated versions of short sequences of module instructions ending in control-flow transfers--called \emph{basic blocks}. Translated basic blocks have the same execution behaviour as native module code, but contain additional instrumentation code and always yield control back to {\Sysname}. 

%{\Sysname} enables analysis of arbitrary kernel modules by using DBT instead of special hardware features like virtualization or protection domains. DBT allows for comprehensiveness by controlling the execution of all module code. , only translated versions of short sequences of module instructions ending in control-flow transfers--called \emph{basic blocks}--can be executed. Translated module code behaves in the same way as normal module code, but contains additional instrumentation code. The additional instrumentation code enables precise module analysis.


%We identified four features needed to make module analysis practical

%The existing solution which attempts to isolate the kernel modules and understand its interactions with the kernel uses different approach like compile-time and run-time checking/annotations, hardware protection domain, and by extending virtual machines (VMs) and hypervisors with the ability to introspect and monitor a running kernel and its modules. While these approaches have already achieved many of the goals, all suffer from at least one of the following issues: i) they depend on VMs/hypervisors, and thus limit the breadth of kernel modules which can be monitored, or; ii) they require a custom compilation toolchain and/or kernel modifications, and so limit the likelihood of their integration with existing OS build processes.

%In this work we present {\sysname}, a framework for efficiently instrumenting Linux kernel modules. {\sysname} uses dynamic binary translation to dynamically rewrite and comprehensively instrument kernel modules. The extensive use of compile-time meta-programming driven by static type information enables us to efficiently analyze its dynamic behaviour. Our approach is novel because {\sysname} can instrument arbitrary, binary kernel modules without imposing any overhead on non-instrumented kernel code.

%The goal of comprehensivness requires that {\sysname} control the execution of all module code. This is achieved by attaching instrumentation when module code first gets executed and leaving it attached until the next context switch to kernel code. The second goal requires that any overhead introduced by {\sysname} only affect instrumented modules. The {\sysname} introduces overhead when it translated, caches, and executes instrumented code leaving kernel execution unaffected. The attaching and detaching of the instrumentation framework causes the execution to switch between native and instrumented mode. This makes it challenging to maintain the module isolation and consistency of the interrupt and exceptions.

%Instrumenting only module code requires that {\sysname} should be able to dynamically gain control on all raw kernel module entry point and relinquish control when control transfers to the kernel. Interposing on the control-flow transfers leading to mode switch is easy when module executes under the control of {\sysname} but is challenging when kernel code executes. Page protection is one method that can be used to detect the control-flow transfer to the modules, where all modules code can be made non-executable and any attempt to execute them results in a page fault exeception that will be handled by {\sysname} to attach instrumentation. Considering the cost associated with page-fault handling, {\sysname} takes an alternative approach where it interposes during module loading mechanism changing the module entry point, allowing for efficient entry point interposition.{\sysname} uses a type based kernel wrapper which pro-actively wraps all the associated function pointers passed to the kernel making it easy for itself to gain control when kernel calls raw module. However, wrapping and re-wrapping of these function pointers deeply nested into the kernel objects each time on context switch makes it expensive. {\sysname} tracks the kernel object passed over the kernel-module interface and embedding the meta-information of its last state and enabling the re-wrapping of the kernel objects on its state change. Type based kernel wrapper and dynamic tracking of the kernel objects enables the scope of dynamic wrapper for {\sysname}, which helps it to analyze the different instance of the kernel object differently. {\sysname} uses page-protection as a fall-though which ensures that raw module never gets executed.

{\Sysname} is a work in progress. It works on multi-core processors with pre-emptive kernels, and incurs a modest decrease in throughput of 10\% to 50\% for network device drivers. We have used {\sysname} to isolate and comprehensively instrument several network device drivers (e1000, e1000e, ixgbe, tg3) and file system modules (ext2, ext3). We have used {\sysname} to develop an application which enforces partial control-flow integrity policies. These policies disallow modules from executing dangerous control-flow transfers. As a future work, we plan on implementing more optimizations and applications. 

\bibliographystyle{abbrvnat}
\bibliography{library}

\symbolfootnote[0]{* Student}

\end{document}


