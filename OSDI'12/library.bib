
@article{Belazzougui_Botelho_2008, title={Hash, displace, and compress}, volume={3}, journal={Education}, publisher={Springer}, author={Belazzougui, Djamal and Botelho, Fabiano C}, year={2008}, pages={682Ð693}}

@misc{Feiner2010a,
author = {Feiner, Peter and Demke-Brown, Angela and Goel, Ashvin},
title = {{Transparent Fault Isolation using Dynamic Compilation (Poster)}},
booktitle = {ASPLOS},
publisher = {ACM},
year={2010},
address = {Pittsburgh, PA},
}

@inproceedings{Feiner2010b,
author = {Feiner, Peter and Demke-Brown, Angela and Goel, Ashvin},
title = {{A Design for Comprehensive Kernel Instrumentation}},
booktitle = {HOTDEP},
publisher = {USENIX Association},
year = {2010},
address = {Vancouver, Canada},
}

@inproceedings{Feiner2012,
author = {Feiner, Peter and Demke-Brown, Angela and Goel, Ashvin},
title = {{Comprehensive Kernel Instrumentation via Dynamic Binary Translation}},
booktitle = {ASPLOS},
publisher = {ACM},
year = {2012},
}

@inproceedings{Zhao2010,
author = {Zhao, Qin and Bruening, Derek and Amarasinghe, Saman},
title = {{Umbra: Efficient and Scalable Memory Shadowing}},
booktitle = {ASPLOS},
publisher = {ACM},
year = {2010},
address = {Toronto, Canada},
}

@inproceedings{Zhao2010a,
author = {Zhao, Qin and Bruening, Derek and Amarasinghe, Saman},
title = {{Efficient Memory Shadowing for 64-bit Architectures}},
booktitle = {ISMM},
year = {2010},
}

@misc{Windows64BitDriverChecklist,
author = {Microsoft},
title = {{Checklist for 64-bit Microsoft Windows Drivers.}},
note = {\url{http://www.microsoft.com/whdc/driver/kernel/64bit_chklist.mspx}},
year = {2008}
}

@book{Bovet2005,
address = {Sebastopol, CA},
author = {Bovet, Daniel P. and Cesati, Marco},
booktitle = {Understanding the Linux Kernel},
edition = {3rd},
publisher = {O'Reilly},
title = {{Understanding the Linux Kernel}},
year = {2005}
}

@inbook{Orwick2007,
address = {Redmond, WA},
author = {Orwick, Penny and Smith, Guy},
booktitle = {Developing Drivers with the Windows Driver Foundation},
publisher = {Microsoft Press},
title = {Developing Drivers with the Windows Driver Foundation},
year = {2007}
}

@article{Bala2000a,
author = {Bala, Vasanth and Duesterwald, Evelyn and Banerjia, Sanjeev},
file = {:home/peter/Documents/Mendeley Desktop/PLDI - 2000 - Dynamo a transparent dynamic optimization system - Bala, Duesterwald, Banerjia.pdf:pdf},
journal = {PLDI},
pages = {1--12},
title = {{Dynamo: A Transparent Dynamic Optimization System}},
year = {2000}
}
@article{Wahbe1994,
abstract = {One way to provide fault isolation among cooperating software modules is to place each in its own address space. However, for tightly-coupled modules, this solution incurs prohibitive context switch overhead. In this paper, we present a software approach to implementing fault isolation within a single address space.Our approach has two parts. First, we load the code and data for a distrusted module into its own fault do main, a logically separate portion of the application's address space. Second, we modify the object code of a distrusted module to prevent it from writing or jumping to an address outside its fault domain. Both these software operations are portable and programming language independent.Our approach poses a tradeoff relative to hardware fault isolation: substantially faster communication between fault domains, at a cost of slightly increased execution time for distrusted modules. We demonstrate that for frequently communicating modules, implementing fault isolation in software rather than hardware can substantially improve end-to-end application performance.},
author = {Wahbe, Robert and Lucco, Steven and Anderson, Thomas E. and Graham, Susan L.},
journal = {ACM Symposium on Operating Systems Principles},
number = {5},
title = {{Efficient software-based fault isolation}},
volume = {27},
year = {1994}
}
@inproceedings{Wahbe1993,
abstract = {One way to provide fault isolation among cooperating software modules is to place each in its own address space. However, for tightly-coupled modules, this solution incurs prohibitive context switch overhead. In this paper, we present a software approach to implementing fault isolation within a single address space. Our approach has two parts. First, we load the code and data for a distrusted module into its own fault domain, a logically separate portion of the application's address space. Second, we modify the object code of a distrusted module to prevent it from writing or jumping to an address outside its fault domain. Both these software operations are portable and programming language independent. Our approach poses a tradeoff relative to hardware fault isolation: substantially faster communication between fault domains, at a cost of slightly increased execution time for distrusted modules. We demonstrate that for frequently communicating modules, implementing fault isolation in s...},
address = {Asheville, NC},
author = {Wahbe, Robert and Lucco, Steven and Anderson, Thomas E. and Graham, Susan L.},
booktitle = {SOSP},
doi = {10.1.1.29.6589},
file = {:home/peter/Documents/Mendeley Desktop/SOSP - 1993 - Efficient Software-Based Fault Isolation - Wahbe et al.pdf:pdf},
pages = {203--216},
publisher = {ACM},
title = {{Efficient Software-Based Fault Isolation}},
year = {1993}
}
@article{Wahbe1994a,
abstract = {One way to provide fault isolation among cooperating software modules is to place each in its own address space. However, for tightly-coupled modules, this solution incurs prohibitive context switch overhead. In this paper, we present a software approach to implementing fault isolation within a single address space.Our approach has two parts. First, we load the code and data for a distrusted module into its own fault do main, a logically separate portion of the application's address space. Second, we modify the object code of a distrusted module to prevent it from writing or jumping to an address outside its fault domain. Both these software operations are portable and programming language independent.Our approach poses a tradeoff relative to hardware fault isolation: substantially faster communication between fault domains, at a cost of slightly increased execution time for distrusted modules. We demonstrate that for frequently communicating modules, implementing fault isolation in software rather than hardware can substantially improve end-to-end application performance.},
author = {Wahbe, Robert and Lucco, Steven and Anderson, Thomas E. and Graham, Susan L.},
journal = {ACM Symposium on Operating Systems Principles},
number = {5},
title = {{Efficient software-based fault isolation}},
volume = {27},
year = {1994}
}

@inproceedings{Qemu2005,
 author = {Bellard, Fabrice},
 title = {QEMU, a fast and portable dynamic translator},
 booktitle = {Proceedings of the annual conference on USENIX Annual Technical Conference},
 series = {ATEC '05},
 year = {2005},
 location = {Anaheim, CA},
 pages = {41--41},
 numpages = {1},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
} 

@inproceedings{Bala2000,
abstract = {We describe the design and implementation of Dynamo, a software dynamic optimization system that is capable of transparently improving the performance of a native instruction stream as it executes on the processor. The input native instruction stream to Dynamo can be dynamically generated (by a JIT for example), or it can come from the execution of a statically compiled native binary. This paper evaluates the Dynamo system in the latter, more challenging situation, in order to emphasize the limits, rather than the potential, of the system. Our experiments demonstrate that even statically optimized native binaries can be accelerated Dynamo, and often by a significant degree. For example, the average performance of -O optimized SpecInt95 benchmark binaries created by the HP product C   compiler is improved to a level comparable to their -O4 optimized version running without Dynamo. Dynamo achieves this by focusing its efforts on optimization opportunities that tend to manifest only at runtime, and hence opportunities that might be difficult for a static compiler to exploit. Dynamo's operation is transparent in the sense that it does not depend on any user annotations or binary instrumentation, and does not require multiple runs, or any special compiler, operating system or hardware support. The Dynamo prototype presented here is a realistic implementation running on an HP PA-8000 workstation under the HPUX 10.20 operating system.},
address = {Vancouver, Canada},
annote = {What about hot paths through thread schedules? This could eliminate locking in some situations. That is, make the two separate threads code in a single thread, thus serializing the work and getting rid of the lock. Doing this would obviously get rid of concurrency, but in some cases perhaps the concurrency doesn't result in faster execution because of the overhead of scheduling??},
author = {Bala, Vasanth and Duesterwald, Evelyn and Banerjia, Sanjeev},
booktitle = {PLDI},
file = {:home/peter/Documents/Mendeley Desktop/PLDI - 2000 - Dynamo a transparent dynamic optimization system - Bala, Duesterwald, Banerjia.pdf:pdf},
number = {5},
pages = {1--12},
publisher = {ACM},
title = {{Dynamo: a transparent dynamic optimization system}},
volume = {35},
year = {2000}
}
@article{Zaleski2007,
abstract = {The design of new programming languages benefits from interpretation, which can provide a simple initial implementation, flexibility to explore new language features, and portability to many platforms. The only downside is speed of execution, as there remains a large performance gap between even efficient interpreters and mixed-mode systems that include a just-in-time compiler (or JIT for short). Augmenting an interpreter with a JIT, however, is not a small task. Today, JITs used for Javaâ„¢ are loosely-coupled with the interpreter, with callsites of methods being the only transition point between interpreted and native code. To compile whole methods, the JIT must duplicate a sizable amount of functionality already provided by the interpreter, leading to a "big bang" development effort before the JIT can be deployed. Instead, adding a JIT to an interpreter would be easier if it were possible to leverage the existing functionality. In earlier work we showed that packaging virtual instructions as lightweight callable routines is an efficient way to build an interpreter. In this paper we describe how callable bodies help our interpreter to efficiently identify and run traces. Our closely coupled dynamic compiler can fall back on the interpreter in various ways, permitting an incremental approach in which additional performance gains can be realized as it is extended in two dimensions: (i) generating code for more types of virtual instructions, and (ii) identifying larger compilation units. Currently, Yeti identifies straight line regions of code and traces, and generates non-optimized code for roughly 50 Java integer and object bytecodes. Yeti runs roughly twice as fast as a direct-threaded interpreter on SPECjvm98 benchmarks.},
author = {Zaleski, Mathew and Demke-Brown, Angela and Stoodley, Kevin},
file = {:home/peter/Documents/Mendeley Desktop/VEE - 2007 - YETI a graduallY extensible trace interpreter - Zaleski, Demke-Brown, Stoodley(2).pdf:pdf;:home/peter/Documents/Mendeley Desktop/VEE - 2007 - YETI a graduallY extensible trace interpreter - Zaleski, Demke-Brown, Stoodley.pdf:pdf},
journal = {VEE},
keywords = {JIT compiler,interpreter,mixed-mode,trace},
title = {{YETI: a graduallY extensible trace interpreter}},
year = {2007}
}
@article{Cadar2006,
author = {Cadar, C. and Ganesh, V. and Pawlowski, P.M. and Dill, D.L. and Engler, D.R.},
file = {:home/peter/Documents/Mendeley Desktop/CCS - 2006 - EXE automatically generating inputs of death - Cadar et al..pdf:pdf},
journal = {CCS},
keywords = {attack generation,bolic execution,bug nding,constraint solving,dynamic analysis,sym-,test case generation},
publisher = {ACM},
title = {{EXE: automatically generating inputs of death}},
year = {2006}
}
@article{Cadar2008,
author = {Cadar, C. and Dunbar, D. and Engler, D.},
file = {:home/peter/Documents/Mendeley Desktop/OSDI - 2008 - KLEE Unassisted and automatic generation of high-coverage tests for complex systems programs - Cadar, Dunbar, Engler.pdf:pdf},
journal = {OSDI},
title = {{KLEE: Unassisted and automatic generation of high-coverage tests for complex systems programs}},
year = {2008}
}
@article{Engler2000,
author = {Engler, D. and Chelf, B. and Chou, A. and Hallem, S.},
file = {:home/peter/Documents/Mendeley Desktop/OSDI - 2000 - Checking system rules using system-specific, programmer-written compiler extensions - Engler et al..pdf:pdf},
journal = {OSDI},
pages = {1--1},
publisher = {USENIX Association Berkeley, CA, USA},
title = {{Checking system rules using system-specific, programmer-written compiler extensions}},
year = {2000}
}
@inproceedings{Yee2009,
address = {Oakland, CA},
author = {Yee, Bennet and Sehr, David and Dardyk, Gregory and Chen, Bradley and Muth, Robert and Ormandy, Tavis and Okasaka, Shiki and Narula, Neha and Fullagar, Nicholas},
booktitle = {SP},
file = {:home/peter/Documents/Mendeley Desktop/SP - 2009 - Native Client A Sandbox for Portable, Untrusted x86 Native Code - Yee et al.pdf:pdf},
pages = {79--93},
publisher = {IEEE Computer Society},
title = {{Native Client: A Sandbox for Portable, Untrusted x86 Native Code}},
year = {2009}
}
@article{Small1998,
abstract = {Extensible applications extend system behavior but often at the expense of system security. The authors developed their Minimal i386 Software Fault Isolation Tool to protect applications from end-user extensions written in otherwise unsafe languages. They demonstrate how MiSFIT transforms unsafe x86 assembler code into safe code, and they discuss future research possibilites for further improving MiSFIT.},
author = {Small, Christopher and Seltzer, Margo I.},
issn = {1092-3063},
journal = {IEEE Concurrency},
number = {3},
title = {{MiSFIT: Constructing Safe Extensible Systems}},
volume = {6},
year = {1998}
}
@inproceedings{Amarasinghe2003,
abstract = {We present program shepherding, a method for monitoring control flow transfers during program execution in order to enforce a security policy. Program shepherding provides three basic techniques as building blocks for security policies. First, program shepherding can restrict execution privileges on the basis of code origins. This distinction can ensure that malicious code masquerading as data is never executed, thwarting a large class of security attacks. Second, shepherding can restrict control transfers based on instruction type, source, and target. Finally, shepherding guarantees that sandboxing checks around any program operation will never be bypassed.},
author = {Amarasinghe, Saman P. and Kiriansky, V L and Kiriansky, Vladimir L.},
booktitle = {In USENIX Security Symposium},
doi = {10.1.1.12.6342},
file = {:home/peter/Documents/Mendeley Desktop/In USENIX Security Symposium - 2003 - Secure Execution Environment via Program Shepherding - Amarasinghe, Kiriansky, Kiriansky.pdf:pdf},
title = {{Secure Execution Environment via Program Shepherding}},
year = {2003}
}

@article{Swift2006,
abstract = {This article presents a new mechanism that enables applications to run correctly when device drivers fail. Because device drivers are the principal failing component in most systems, reducing driver-induced failures greatly improves overall reliability. Earlier work has shown that an operating system can survive driver failures \&lsqb;Swift et al. 2005\&rsqb;, but the applications that depend on them cannot. Thus, while operating system reliability was greatly improved, application reliability generally was not.To remedy this situation, we introduce a new operating system mechanism called a shadow driver. A shadow driver monitors device drivers and transparently recovers from driver failures. Moreover, it assumes the role of the failed driver during recovery. In this way, applications using the failed driver, as well as the kernel itself, continue to function as expected.We implemented shadow drivers for the Linux operating system and tested them on over a dozen device drivers. Our results show that applications and the OS can indeed survive the failure of a variety of device drivers. Moreover, shadow drivers impose minimal performance overhead. Lastly, they can be introduced with only modest changes to the OS kernel and with no changes at all to existing device drivers.},
author = {Swift, Michael M. and Annamalai, Muthukaruppan and Bershad, Brian N. and Levy, Henry M.},
file = {:home/peter/Documents/Mendeley Desktop/TOCS - 2006 - Recovering device drivers - Swift et al.pdf:pdf},
issn = {0734-2071},
journal = {TOCS},
keywords = {I/O,Recovery,device drivers},
number = {4},
title = {{Recovering device drivers}},
volume = {24},
year = {2006}
}
@article{Swift2005,
abstract = {Despite decades of research in extensible operating system technology, extensions such as device drivers remain a significant cause of system failures. In Windows XP, for example, drivers account for 85\&percent; of recently reported failures.This article describes Nooks, a reliability subsystem that seeks to greatly enhance operating system (OS) reliability by isolating the OS from driver failures. The Nooks approach is practical: rather than guaranteeing complete fault tolerance through a new (and incompatible) OS or driver architecture, our goal is to prevent the vast majority of driver-caused crashes with little or no change to the existing driver and system code. Nooks isolates drivers within lightweight protection domains inside the kernel address space, where hardware and software prevent them from corrupting the kernel. Nooks also tracks a driver's use of kernel resources to facilitate automatic cleanup during recovery.To prove the viability of our approach, we implemented Nooks in the Linux operating system and used it to fault-isolate several device drivers. Our results show that Nooks offers a substantial increase in the reliability of operating systems, catching and quickly recovering from many faults that would otherwise crash the system. Under a wide range and number of fault conditions, we show that Nooks recovers automatically from 99\&percent; of the faults that otherwise cause Linux to crash.While Nooks was designed for drivers, our techniques generalize to other kernel extensions. We demonstrate this by isolating a kernel-mode file system and an in-kernel Internet service. Overall, because Nooks supports existing C-language extensions, runs on a commodity operating system and hardware, and enables automated recovery, it represents a substantial step beyond the specialized architectures and type-safe languages required by previous efforts directed at safe extensibility.},
author = {Swift, Michael M. and Bershad, Brian N. and Levy, Henry M.},
issn = {0734-2071},
journal = {TOCS},
keywords = {I/O,Recovery,device drivers,protection,virtual memory},
number = {1},
title = {{Improving the reliability of commodity operating systems}},
volume = {23},
year = {2005}
}
@article{Swift2002,
abstract = {With the enormous growth in processor performance over the last decade, it is clear that reliability, rather than performance, is now the greatest challenge for computer systems research. This is particularly true in the context of Internet services that require 24x7 operation and home computers with no professional administration. While operating system products have matured and become more reliable, they are still the source of a significant number of failures. Furthermore, recent studies show that device drivers are frequently responsible for operating system failures. For example, a study at Stanford University found that Linux drivers have 3 to 7 times the bug frequency as the rest of the OS [4]. An analysis of product support calls for Windows 2000 showed that device drivers accounted for 27\% of crashes, compared to 2\% for the kernel itself [16].},
author = {Swift, Michael M. and Martin, Steven and Levy, Henry M. and Eggers, Susan J.},
file = {:home/peter/Documents/Mendeley Desktop/ACM SIGOPS European Workshop - 2002 - Nooks an architecture for reliable device drivers - Swift et al.pdf:pdf},
journal = {ACM SIGOPS European Workshop},
title = {{Nooks: an architecture for reliable device drivers}},
year = {2002}
}

@inproceedings{Seltzer1996,
abstract = {Today's extensible operating systems allow applications to modify kernel behavior by providing mechanisms for application code to run in the kernel address space. The advantage of this approach is that it provides improved application flexibility and performance; the disadvantage is that buggy or malicious code can jeopardize the integrity of the kernel. It has been demonstrated that it is feasible to use safe languages, software fault isolation, or virtual memory protection to safeguard the main kernel. However, such protection mechanisms do not address the full range of problems, such as resource hoarding, that can arise when application code is introduced into the kernel. In this paper, we present an analysis of extension mechanisms in the VINO kernel. VINO uses software fault isolation as its safety mechanism and a lightweight transaction system to cope with resource-hoarding. We explain how these two mechanisms are sufficient to protect against a large class of errant or malicious...},
address = {Seattle, WA},
author = {Seltzer, Margo and Seltzer, Margo I. and Endo, Yasuhiro and Small, Christopher and Smith, Keith A.},
booktitle = {OSDI},
doi = {10.1.1.40.6958},
file = {:home/peter/Documents/Mendeley Desktop/OSDI - 1996 - Dealing With Disaster Surviving Misbehaved Kernel Extensions - Seltzer et al.pdf:pdf},
pages = {213--227},
publisher = {USENIX Association},
title = {{Dealing With Disaster: Surviving Misbehaved Kernel Extensions}},
year = {1996}
}
@inproceedings{Castro2009,
abstract = {Bugs in kernel extensions remain one of the main causes of poor operating system reliability despite proposed techniques that isolate extensions in separate protection domains to contain faults. We believe that previous fault isolation techniques are not widely used because they cannot isolate existing kernel extensions with low overhead on standard hardware. This is a hard problem because these extensions communicate with the kernel using a complex interface and they communicate frequently. We present BGI (Byte-Granularity Isolation), a new software fault isolation technique that addresses this problem. BGI uses efficient byte-granularity memory protection to isolate kernel extensions in separate protection domains that share the same address space. BGI ensures type safety for kernel objects and it can detect common types of errors inside domains. Our results show that BGI is practical: it can isolate Windows drivers without requiring changes to the source code and it introduces a CPU overhead between 0 and 16\%. BGI can also find bugs during driver testing. We found 28 new bugs in widely used Windows drivers.},
address = {Big Sky, MT},
annote = {Can all of this be done JIT without access to the source code?

        
- can't do local variable permissions. might have to grant read / write on all bytes in the domain's stack -- this messes up control flow integrity. Problem with CFI can be mitigated by tagging the stack frame when the routine is entered. Could try to calculate where data exists on the stack, i.e, between stack frames, and tag these regions.

        
Call checks  (page 6) might be hard to do without source code. Maybe the function's code and where it's called can be scanned to determine how it works. Exported function pointers must use some standard calling convention.

        
2nd paragraph in S6.3 says that icall rights are only granted to a single domain (i.e., the domain that the function code is in). How does sharing function pointers between domains work then?},
author = {Castro, Miguel and Costa, Manuel and Martin, Jean-Philippe and Peinado, Marcus and Akritidis, Periklis and Donnelly, Austin and Barham, Paul and Black, Richard},
booktitle = {SOSP},
file = {:home/peter/Documents/Mendeley Desktop/SOSP - 2009 - Fast Byte-Granularity Software Fault Isolation - Castro et al.pdf:pdf},
keywords = {device drivers,isolation},
pages = {45--58},
publisher = {ACM},
title = {{Fast Byte-Granularity Software Fault Isolation}},
year = {2009}
}
@article{Sokol2009,
author = {Sokol, H Nancy},
file = {:home/peter/Documents/Mendeley Desktop/Unknown - 2009 - Diagnostic testing for low back pain - Sokol.pdf:pdf},
title = {{Diagnostic testing for low back pain}},
year = {2009}
}
@inproceedings{Swift2003,
abstract = {Despite decades of research in extensible operating system technology, extensions such as device drivers remain a significant cause of system failures. In Windows XP, for example, drivers account for 85\% of recently reported failures. This paper describes Nooks, a reliability subsystem that seeks to greatly enhance OS reliability by isolating the OS from driver failures. The Nooks approach is practical: rather than guaranteeing complete fault tolerance through a new (and incompatible) OS or driver architecture, our goal is to prevent the vast majority of driver-caused crashes with little or no change to existing driver and system code. To achieve this, Nooks isolates drivers within lightweight protection domains inside the kernel address space, where hardware and software prevent them from corrupting the kernel. Nooks also tracks a driver's use of kernel resources to hasten automatic clean-up during recovery.To prove the viability of our approach, we implemented Nooks in the Linux operating system and used it to fault-isolate several device drivers. Our results show that Nooks offers a substantial increase in the reliability of operating systems, catching and quickly recovering from many faults that would otherwise crash the system. In a series of 2000 fault-injection tests, Nooks recovered automatically from 99\% of the faults that caused Linux to crash.While Nooks was designed for drivers, our techniques generalize to other kernel extensions, as well. We demonstrate this by isolating a kernel-mode file system and an in-kernel Internet service. Overall, because Nooks supports existing C-language extensions, runs on a commodity operating system and hardware, and enables automated recovery, it represents a substantial step beyond the specialized architectures and type-safe languages required by previous efforts directed at safe extensibility.},
address = {Bolton Landing, NY},
annote = {-2nd last paragraph if S4.5 says updates to kernel structures are atomic. This is true, but updates to a bunch of kernel structures that form a single logical operation are not atomic.
- BGI does not ensure atomic updates},
author = {Swift, Michael M. and Bershad, Brian N. and Levy, Henry M.},
booktitle = {SOSP},
keywords = {I/O,device drivers,protection,recovery,virtual memory},
number = {5},
pages = {207--222},
publisher = {ACM},
title = {{Improving the Reliability of Commodity Operating Systems}},
volume = {37},
year = {2003}
}
@inproceedings{David2008,
address = {San Diego, CA},
author = {David, F.M. and Chan, E.M. and Carlyle, J.C. and Campbell, R.H.},
booktitle = {OSDI},
file = {:home/peter/Documents/Mendeley Desktop/OSDI - 2008 - CuriOS Improving Reliability Through Operating System @Structure - David et al.pdf:pdf},
pages = {59--72},
publisher = {USENIX Association},
title = {{CuriOS: Improving Reliability Through Operating System @Structure}},
year = {2008}
}
@inproceedings{Lowell2000,
abstract = {We explore the abstraction of failure transparency in which the operating system provides the illusion of failure-free operation. To provide failure transparency, an operating system must recover applications after hardware, operating system, and application failures, and must do so without help from the programmer or unduly slowing failure-free performance. We describe two invariants that must be upheld to provide failure transparency: one that ensures sufficient application state is saved to guarantee the user cannot discern failures, and another that ensures sufficient application state is lost to allow recovery from failures affecting application state. We find that several real applications get failure transparency in the presence of simple stop failures with overhead of 0-12\%. Less encouragingly, we find that applications violate one invariant in the course of upholding the other for more than 90\% of application faults and 3-15\% of operating system faults, rendering transparent recovery impossible for these cases.},
address = {San Diego, CA},
author = {Lowell, David E. and Chandra, Subhachandra and Chen, Peter M.},
booktitle = {OSDI},
file = {:home/peter/Documents/Mendeley Desktop/OSDI - 2000 - Exploring Failure Transparency and the Limits of Generic Recovery - Lowell, Chandra, Chen.pdf:pdf},
pages = {289--304},
publisher = {USENIX Association},
title = {{Exploring Failure Transparency and the Limits of Generic Recovery}},
year = {2000}
}
@inproceedings{Saxena2008,
abstract = {Fine-grained binary instrumentations, such as those for taint-tracking, have become very popular in computer security due to their applications in exploit detection, sandboxing, malware analysis, etc. However, practical application of taint-tracking has been limited by high performance overheads. For instance, previous software based techniques for taint-tracking on binary code have typically slowed down programs by a factor of 3 or more. In contrast, source-code based techniques have achieved better performance using high level optimizations. Unfortunately, these optimizations are difficult to perform on binaries since much of the high level program structure required by such static analyses is lost during the compilation process. In this paper, we address this challenge by developing static techniques that can recover some of the higher level structure from x86 binaries. Our new static analysis enables effective optimizations, which are applied in the context of taint tracking. As a result, we achieve a substantial reduction in performance overheads as compared to previous works.},
address = {Boston, MA},
author = {Saxena, Prateek and Sekar, R and Puranik, Varun},
booktitle = {CGO},
file = {:home/peter/Documents/Mendeley Desktop/CGO - 2008 - Efficient Fine-Grained Binary Instrumentation with Applications to Taint-Tracking - Saxena, Sekar, Puranik.pdf:pdf},
keywords = {binary analysis/rewriting,information flow,taint tracking},
pages = {74--83},
publisher = {ACM},
title = {{Efficient Fine-Grained Binary Instrumentation with Applications to Taint-Tracking}},
year = {2008}
}
@article{Cousot1992,
author = {Cousot, Patrick and Cousot, Rahida},
file = {:home/peter/Documents/Mendeley Desktop/Journal of Logic Programming - 1992 - Abstract interpretation and application to logic programs - Cousot, Cousot.pdf:pdf},
issn = {0743-1066},
journal = {Journal of Logic Programming},
number = {2},
title = {{Abstract interpretation and application to logic programs}},
volume = {13},
year = {1992}
}
@book{GDB, title={Debugging with gdb}, volume={20081221}, url={http://jamsb.austms.org.au/courses/CSC2408/semester2/resources/course/gdb.pdf}, number={April}, journal={Managing}, publisher={Free Software Foundation}, author={Stallman, Richard and Pesch, Roland and Shebs, Stan}, editor={Foundation, Free SoftwareEditor}, year={2002}, pages={346}}

@inproceedings{Olszewski2007,
abstract = {As modern operating systems become more complex, understanding their inner workings is increasingly difficult. Dynamic kernel instrumentation is a well established method of obtaining insight into the workings of an OS, with applications including debugging, profiling and monitoring, and security auditing. To date, all dynamic instrumentation systems for operating systems follow the probe-based instrumentation paradigm. While efficient on fixed-length instruction set architectures, probes are extremely expensive on variable-length ISAs such as the popular Intel x86 and AMD x86-64. We propose using just-in-time (JIT) instrumentation to overcome this problem. While common in user space, JIT instrumentation has not until now been attempted in kernel space. In this work, we show the feasibility and desirability of kernel-based JIT instrumentation for operating systems with our novel prototype, implemented as a Linux kernel module. The prototype is fully SMP capable. We evaluate our prototype against the popular Kprobes Linux instrumentation tool. Our prototype outperforms Kprobes, at both micro and macro levels, by orders of magnitude when applying medium- and fine-grained instrumentation.},
address = {Lisbon, Portugal},
author = {Olszewski, Marek and Mierle, Keir and Czajkowski, Adam and Brown, Angela Demke},
booktitle = {EUROSYS},
file = {:home/peter/Documents/Mendeley Desktop/EUROSYS - 2007 - JIT Instrumentation a Novel Approach to Dynamically Instrument Operating Systems - Olszewski et al.pdf:pdf},
issn = {0163-5980},
keywords = {JIT compiler,binary rewriting,dynamic instrumentation,kernel analysis tools},
pages = {3--16},
publisher = {ACM},
title = {{JIT Instrumentation: a Novel Approach to Dynamically Instrument Operating Systems}},
year = {2007}
}
@inproceedings{Bruening2003,
abstract = {Dynamic optimization is emerging as a promising approach to overcome many of the obstacles of traditional static compilation. But while there are a number of compiler infrastructures for developing static optimizations, there are very few for developing dynamic optimizations. We present a framework for implementing dynamic analyses and optimizations. We provide an interface for building external modules, or clients, for the DynamoRlO dynamic code modification system. This interface abstracts away many low-level details of the DynamoRlO runtime system while exposing a simple and powerful, yet efficient and lightweight, API. This is achieved by restricting optimization units to linear streams of code and using adaptive levels of detail for representing instructions. The interface is not restricted to optimization and can be used for instrumentation, profiling, dynamic translation, etc.To demonstrate the usefulness and effectiveness of our framework, we implemented several optimizations. These improve the performance of some applications by as much as 40\% relative to native execution. The average speedup relative to base DynamoRlO performance is 12\%.},
address = {San Francisco, CA},
author = {Bruening, Derek and Garnett, Timothy and Amarasinghe, Saman},
booktitle = {CGO},
file = {:home/peter/Documents/Mendeley Desktop/CGO - 2003 - An infrastructure for adaptive dynamic optimization - Bruening, Garnett, Amarasinghe.pdf:pdf},
pages = {265--275},
publisher = {ACM},
title = {{An infrastructure for adaptive dynamic optimization}},
year = {2003}
}
@article{Hunt2007,
abstract = {Every operating system embodies a collection of design decisions. Many of the decisions behind today's most popular operating systems have remained unchanged, even as hardware and software have evolved. Operating systems form the foundation of almost every software stack, so inadequacies in present systems have a pervasive impact. This paper describes the efforts of the Singularity project to re-examine these design choices in light of advances in programming languages and verification tools. Singularity systems incorporate three key architectural features: software-isolated processes for protection of programs and system services, contract-based channels for communication, and manifest-based programs for verification of system properties. We describe this foundation in detail and sketch the ongoing research in experimental systems that build upon it.},
author = {Hunt, Galen C. and Larus, James R.},
issn = {0163-5980},
journal = {ACM SIGOPS},
keywords = {hardware protection domains,manifest-based programs (MBPs),operating systems,program specification,program verification,safe programming languages,sealed kernel,sealed process architecture,software-isolated processes (SIPs),unsafe code tax},
number = {2},
pages = {37--49},
title = {{Singularity: Rethinking the Software Stack}},
volume = {41},
year = {2007}
}
@inproceedings{Kiriansky2002,
address = {San Francisco, CA},
author = {Kiriansky, Vladimir and Bruening, Derek and Amarasinghe, Saman P.},
booktitle = {USENIX Security},
file = {:home/peter/Documents/Mendeley Desktop/USENIX Security - 2002 - Secure Execution via Program Shepherding - Kiriansky, Bruening, Amarasinghe.pdf:pdf},
pages = {191--206},
publisher = {USENIX Association},
title = {{Secure Execution via Program Shepherding}},
year = {2002}
}
@inproceedings{Castro2006,
abstract = {Software attacks often subvert the intended data-flow in a vulnerable program. For example, attackers exploit buffer overflows and format string vulnerabilities to write data to unintended locations. We present a simple technique that prevents these attacks by enforcing data-flow integrity. It computes a data-flow graph using static analysis, and it instruments the program to ensure that the flow of data at runtime is allowed by the data-flow graph. We describe an efficient implementation of data-flow integrity enforcement that uses static analysis to reduce instrumentation overhead. This implementation can be used in practice to detect a broad class of attacks and errors because it can be applied automatically to C and C++ programs without modifications, it does not have false positives, and it has low overhead.},
address = {Seattle, WA},
author = {Castro, Miguel and Costa, Manuel and Harris, Tim},
booktitle = {OSDI},
pages = {147--160},
publisher = {USENIX Association},
title = {{Securing Software by Enforcing Data-Flow Integrity}},
volume = {7},
year = {2006}
}
@inproceedings{Seward2005,
abstract = {We present Memcheck, a tool that has been implemented with the dynamic binary instrumentation framework Valgrind. Memcheck detects a wide range of memory errors in programs as they run. This paper focuses on one kind of error that Memcheck detects: undefined value errors. Such errors are common, and often cause bugs that are hard to find in programs written in languages such as C, C++ and Fortran. Memcheck's definedness checking improves on that of previous tools by being accurate to the level of individual bits. This accuracy gives Memcheck a low false positive and false negative rate. The definedness checking involves shadowing every bit of data in registers and memory with a second bit that indicates if the bit has a defined value. Every value-creating operation is instrumented with a shadow operation that propagates shadow bits appropriately. Memcheck uses these shadow bits to detect uses of undefined values that could adversely affect a program's behaviour. Under Memcheck, programs typically run 20-30 times slower than normal. This is fast enough to use with large programs. Memcheck finds many errors in real programs, and has been used during the past two years by thousands of programmers on a wide range of systems, including OpenOffice, Mozilla, Opera, KDE, GNOME, MySQL, Perl, Samba, The GIMP, and Unreal Tournament.},
address = {Anaheim, CA},
author = {Seward, Julian and Nethercote, Nicholas},
booktitle = {USENIX ATC},
pages = {17--30},
publisher = {USENIX Association},
title = {{Using Valgrind to Detect Undefined Value Errors with Bit-Precision}},
year = {2005}
}
@inproceedings{Nethercote2007a,
address = {San Diego, CA},
author = {Nethercote, Nicholas and Seward, Julian},
booktitle = {PLDI},
file = {:home/peter/Documents/Mendeley Desktop/PLDI - 2007 - Valgrind a framework for heavyweight dynamic binary instrumentation - Nethercote, Seward.pdf:pdf},
pages = {89--100},
publisher = {ACM},
title = {{Valgrind: a framework for heavyweight dynamic binary instrumentation}},
year = {2007}
}
@inproceedings{Akritidis2008,
abstract = {Attacks often exploit memory errors to gain control over the execution of vulnerable programs. These attacks remain a serious problem despite previous research on techniques to prevent them. We present Write Integrity Testing (WIT), a new technique that provides practical protection from these attacks. WIT uses points-to analysis at compile time to compute the control-flow graph and the set of objects that can be written by each instruction in the program. Then it generates code instrumented to prevent instructions from modifying objects that are not in the set computed by the static analysis, and to ensure that indirect control transfers are allowed by the control-flow graph. To improve coverage where the analysis is not precise enough, WIT inserts small guards between the original program objects. We describe an efficient implementation with optimizations to reduce space and time overhead. This implementation can be used in practice because it compiles C and C++ programs without modifications, it has high coverage with no false positives, and it has low overhead. WIT's average runtime overhead is only 7\% across a set of CPU intensive benchmarks and it is negligible when IO is the bottleneck.},
address = {Washington, DC},
author = {Akritidis, Periklis and Cadar, Cristian and Raiciu, Costin and Costa, Manuel and Castro, Miguel},
booktitle = {SP},
keywords = {attack detection,instrumentation,memory errors,static analysis},
pages = {263--277},
publisher = {IEEE Computer Society},
title = {{Preventing Memory Error Exploits with WIT}},
year = {2008}
}
@article{Necula2005,
abstract = {This article describes CCured, a program transformation system that adds type safety guarantees to existing C programs. CCured attempts to verify statically that memory errors cannot occur, and it inserts run-time checks where static verification is insufficient.CCured extends C's type system by separating pointer types according to their usage, and it uses a surprisingly simple type inference algorithm that is able to infer the appropriate pointer kinds for existing C programs. CCured uses physical subtyping to recognize and verify a large number of type casts at compile time. Additional type casts are verified using run-time type information. CCured uses two instrumentation schemes, one that is optimized for performance and one in which metadata is stored in a separate data structure whose shape mirrors that of the original user data. This latter scheme allows instrumented programs to invoke external functions directly on the program's data without the use of a wrapper function.We have used CCured on real-world security-critical network daemons to produce instrumented versions without memory-safety vulnerabilities, and we have found several bugs in these programs. The instrumented code is efficient enough to be used in day-to-day operations.},
author = {Necula, George C. and Condit, Jeremy and Harren, Matthew and McPeak, Scott and Weimer, Westley},
journal = {TOPLAS},
keywords = {Memory safety,libraries,pointer qualifier,subtyping},
number = {3},
pages = {477--526},
title = {{CCured: Type-Safe Retrofitting of Legacy Software}},
volume = {27},
year = {2005}
}
@article{Abadi2007,
author = {Abadi, M. and Budiu, M. and Erlingsson, U. and Ligatti, J.},
file = {:home/peter/Documents/Mendeley Desktop/ACM Transactions on Information and System Security - 2007 - Control-flow integrity Principles, implementations, and applications - Abadi et al.pdf:pdf},
journal = {ACM Transactions on Information and System Security},
publisher = {Citeseer},
title = {{Control-flow integrity: Principles, implementations, and applications}},
year = {2007}
}
@book{Lindholm1999,
abstract = {From the Publisher:The nucleus of the Java 2 platform, the Java virtual machine is the technology that enables the Java 2 platform to host applications on any computer or operating system without rewriting or recompiling. This book was written by those directly responsible for the design and implementation of the Java virtual machine, and is the complete and definitive specification for the technology. It is an essential reference for writers of compilers for the Java programming language and implementors of the Java virtual machine. This second edition specifies the newest version of the Java virtual machine and provides a fascinating view into the inner workings of the Java 2 platform.},
address = {Boston, MA},
author = {Lindholm, Tim and Yellin, Frank},
edition = {2},
publisher = {Addison-Wesley Longman Publishing Co., Inc.},
title = {{Java Virtual Machine Specification}},
year = {1999}
}
@inproceedings{Cheng2006,
abstract = {TaintTrace is a high performance flow tracing tool that protects systems against security exploits. It is based on dynamic execution binary rewriting empowering our tool with fine-grained monitoring of system activities such as the tracking of the usage and propagation of data originated from the network. The challenge lies in minimizing the run-time overhead of the tool. TaintTrace uses a number of techniques such as direct memory mapping to optimize performance. In this paper, we demonstrate that TaintTrace is effective in protecting against various attacks while maintaining a modest slowdown of 5.5 times, offering significant improvements over similar tools.},
author = {Cheng, Winnie and Zhao, Qin and Yu, Bei and Hiroshige, Scott},
booktitle = {ISCC},
pages = {749--754},
publisher = {IEEE Computer Society},
title = {{TaintTrace: Efficient Flow Tracing with Dynamic Binary Rewriting}},
year = {2006}
}
@article{Abadi2009,
abstract = {ppendix to control-flow integrity principles, implementations, and applications. The appendix supports the information on article 4.},
author = {Abadi, Mart\'{\i}n and Budiu, Mihai and Erlingsson, \'{U}lfar and Ligatti, Jay},
journal = {TISSEC},
keywords = {Binary rewriting,control-flow graph,inlined reference monitors,vulnerabilities},
number = {1},
title = {{Control-Flow Integrity Principles, Implementations, and Applications}},
volume = {13},
year = {2009}
}
@inproceedings{Adams2006,
address = {San Jose, CA},
author = {Adams, Keith and Agesen, Ole},
booktitle = {ASPLOS},
file = {:home/peter/Documents/Mendeley Desktop/ASPLOS - 2006 - A comparison of software and hardware techniques for x86 virtualization - Adams, Agesen.pdf:pdf},
pages = {2--13},
publisher = {ACM},
title = {{A comparison of software and hardware techniques for x86 virtualization}},
year = {2006}
}
@inproceedings{Nethercote2007,
abstract = {Several existing dynamic binary analysis tools use shadow memory-they shadow, in software, every byte of memory used by a program with another value that says something about it. Shadow memory is difficult to implement both efficiently and robustly. Nonetheless, existing shadow memory implementations have not been studied in detail. This is unfortunate, because shadow memory is powerful-for example, some of the existing tools that use it detect critical errors such as bad memory accesses, data races, and uses of uninitialised or untrusted data. In this paper we describe the implementation of shadow memory in Memcheck, a popular memory checker built with Valgrind, a dynamic binary instrumentation framework. This implementation has several novel features that make it efficient: carefully chosen data structures and operations result in a mean slow-down factor of only 22.2 and moderate memory usage. This may sound slow, but we show it is 8.9 times faster and 8.5 times smaller on average than a naive implementation, and shadow memory operations account for only about half of Memcheck's execution time. Equally importantly, unlike some tools, Memcheck's shadow memory implementation is robust: it is used on Linux by thousands of programmers on sizeable programs such as Mozilla and OpenOffice, and is suited to almost any memory configuration. This is the first detailed description of a robust shadow memory implementation, and the first detailed experimental evaluation of any shadow memory implementation. The ideas within are applicable to any shadow memory tool built with any instrumentation framework.},
address = {San Diego, CA},
author = {Nethercote, Nicholas and Seward, Julian},
booktitle = {VEE},
keywords = {dynamic binary analysis,dynamic binary instrumentation,memcheck,shadow memory,valgrind},
pages = {65--74},
publisher = {ACM},
title = {{How to Shadow Every Byte of Memory Used by a Program}},
year = {2007}
}
@inproceedings{Erlingsson2006,
address = {Seattle, WA},
author = {Erlingsson, U. and Abadi, M. and Vrable, Michael and Budiu, M. and Necula, G.C.},
booktitle = {OSDI},
pages = {75--88},
publisher = {USENIX Association},
title = {{XFI: Software guards for system address spaces}},
year = {2006}
}
@book{Gosling2005,
abstract = {Written by the inventors of the technology, The Javaâ„¢ Language Specification, Third Edition, is the definitive technical reference for the Javaâ„¢ programming language. If you want to know the precise meaning of the language's constructs, this is the source for you.The book provides complete, accurate, and detailed coverage of the Java programming language. It provides full coverage of all new features added since the previous edition, including generics, annotations, asserts, autoboxing, enums, for-each loops, variable arity methods, and static import clauses.},
author = {Gosling, James and Joy, Bill and Steele, Guy and Bracha, Gilad},
edition = {3rd},
publisher = {Addison-Wesley Professional},
title = {{Java(TM) Language Specification}},
year = {2005}
}
@phdthesis{Bruening2004,
abstract = {This thesis addresses the challenges of building a software system for general-purpose runtime code manipulation. Modern applications, with dynamically-loaded modules and dynamically-generated code, are assembled at runtime. While it was once feasible at compile time to observe and manipulate every instructionâ€”which is critical for program analysis, instrumentation, trace gathering, optimization, and similar toolsâ€”it can now only be done at runtime. Existing runtime tools are successful at inserting instrumentation calls, but no general framework has been developed for fine-grained and comprehensive code observation and modification without high overheads. This thesis demonstrates the feasibility of building such a system in software. We present DynamoRIO, a fully-implemented runtime code manipulation system that supports code transformations on any part of a program, while it executes. DynamoRIO uses code caching technology to provide efficient, transparent, and comprehensive manipulation of an unmodified application running on a stock operating system and commodity hardware. DynamoRIO executes large, complex, modern applications with dynamically-loaded, generated, or even modified code. Despite the formidable obstacles inherent in the IA-32 architecture, DynamoRIO provides these capabilities efficiently, with zero to thirty percent time and memory overhead on both Windows and Linux. DynamoRIO exports an interface for building custom runtime code manipulation tools of all types. It has been used by many researchers, with several hundred downloads of our public release, and is being commercialized in a product for protection against remote security exploits, one of numerous applications of runtime code manipulation. (Copies available exclusively from MIT Libraries, Rm. 14-0551, Cambridge, MA 02139-4307. Ph. 617-253-5668; Fax 617-253-1690.)},
author = {Bruening, Derek},
file = {:home/peter/Documents/Mendeley Desktop/Unknown - 2004 - Efficient, Transparent, and Comprehensive Runtime Code Manipulation. - Bruening.pdf:pdf},
school = {Massachusetts Institute of Technology},
title = {{Efficient, Transparent, and Comprehensive Runtime Code Manipulation.}},
type = {Ph.D. Thesis},
year = {2004}
}
@inproceedings{Bungale2007,
address = {San Diego, CA},
author = {Bungale, P. P. and Luk, C. K.},
booktitle = {VEE},
file = {:home/peter/Documents/Mendeley Desktop/VEE - 2007 - PinOS A programmable framework for whole-system dynamic instrumentation - Bungale, Luk.pdf:pdf},
keywords = {analysis tools,binary translation,dynamic instrumentation,program,virtualization,whole-system},
pages = {137--147},
publisher = {ACM},
title = {{PinOS: A programmable framework for whole-system dynamic instrumentation}},
year = {2007}
}
@inproceedings{Ford2008,
address = {Boston, MA},
author = {Ford, Bryan and Cox, Russ},
booktitle = {USENIX ATC},
file = {:home/peter/Documents/Mendeley Desktop/USENIX ATC - 2008 - Vx32 Lightweight user-level sandboxing on the x86 - Ford, Cox.pdf:pdf},
publisher = {USENIX Association},
title = {{Vx32: Lightweight user-level sandboxing on the x86}},
year = {2008}
}
@article{NaCl,
  author    = {Bennet Yee and
               David Sehr and
               Gregory Dardyk and
               J. Bradley Chen and
               Robert Muth and
               Tavis Ormandy and
               Shiki Okasaka and
               Neha Narula and
               Nicholas Fullagar},
  title     = {Native Client: a sandbox for portable, untrusted x86 native
               code},
  journal   = {Commun. ACM},
  volume    = {53},
  number    = {1},
  year      = {2010},
  pages     = {91-99},
  ee        = {http://doi.acm.org/10.1145/1629175.1629203}
}

@misc{KProbes,
author = {{Linux Technology Center}},
title = {{KProbes. http://sourceware.org/systemtap/kprobes/. Last accessed May 2nd, 2010.}}
}
@inproceedings{Luk2005,
address = {Chicago, IL},
author = {Luk, C. K. and Cohn, Robert and Muth, Robert and Patil, Harish and Klauser, Artur and Lowney, Geoff and Wallace, Steven and Reddi, V. J. and Hazelwood, K.},
booktitle = {PLDI},
file = {:home/peter/Documents/Mendeley Desktop/PLDI - 2005 - Pin building customized program analysis tools with dynamic instrumentation - Luk et al.pdf:pdf},
keywords = {and eventually detach,collect profiles,dynamic com-,instrumentation,program analysis tools,strument it,the application},
pages = {190--200},
publisher = {ACM},
title = {{Pin: building customized program analysis tools with dynamic instrumentation}},
year = {2005}
}
@inproceedings{Chou2001,
address = {Banff, Canada},
author = {Chou, Andy and Yang, Junfeng and Chelf, Benjamin and Hallem, Seth and Engler, Dawson},
booktitle = {SOSP},
doi = {10.1145/502059.502042},
file = {:home/peter/Documents/Mendeley Desktop/SOSP - 2001 - An empirical study of operating systems errors - Chou et al.pdf:pdf},
issn = {01635980},
pages = {73--88},
publisher = {ACM},
title = {{An empirical study of operating systems errors}},
year = {2001}
}
@inproceedings{Bruening2006,
address = {New York, NY},
author = {Bruening, Derek and Kiriansky, Vladimir and Garnett, Timothy and Banerji, Sanjeev},
booktitle = {CGO},
file = {:home/peter/Documents/Mendeley Desktop/CGO - 2006 - Thread-shared software code caches - Bruening et al.pdf:pdf},
publisher = {ACM},
title = {{Thread-shared software code caches}},
url = {http://www.google.com/patents?hl=en\&amp;lr=\&amp;vid=USPATAPP11533712\&amp;id=VaibAAAAEBAJ\&amp;oi=fnd\&amp;dq=Thread-Shared+Software+Code+Caches\&amp;printsec=abstract},
year = {2006}
}
@inproceedings{Seshadri2007,
address = {Stevenson, WA},
author = {Seshadri, Arvind and Luk, Mark and Qu, Ning and Perrig, Adrian},
booktitle = {SOSP},
file = {:home/peter/Documents/Mendeley Desktop/SOSP - 2007 - SecVisor A Tiny Hypervisor to Provide Lifetime Kernel Code Integrity for Commodity OSes - Seshadri et al.pdf:pdf},
keywords = {code attestation,code integrity,hypervisor,ing code injection attacks,memory virtualization,prevent-},
pages = {335--350},
publisher = {ACM},
title = {{SecVisor : A Tiny Hypervisor to Provide Lifetime Kernel Code Integrity for Commodity OSes}},
year = {2007}
}
@book{AMDVolume2,
author = {{Advanced Micro Devices}},
edition = {3.15},
title = {{AMD64 Architecture Programmer's Manual Volume 2: System Programming}},
year = {2009}
}
@book{IntelVolume1,
	author        = {{Intel Corporation}},
	title         = {{Intel\textsuperscript{\textregistered} 64 and IA-32 Architectures Software Developer's Manual}},
	year          = {2009},
	month         = {December},
	number        = {253669-033US},
}
@book{IntelVolume3B,
author = {Intel},
edition = {034},
title = {{Intel 64 and IA-32 Architectures Software Developer's Manual Volume 3B: System Programming Guide, Part 2}},
}
@article{Ruppert2010,
author = {Ruppert, Volker},
title = {{Bochs: The Open Source IA-32 Emulation Project. http://bochs.sourceforge.net/. Last accessed May 25th, 2010.}}
}
@inproceedings{Pohle2010,
address = {Pittsburgh, PA},
author = {Pohle, Aaron and D\"{o}bel, Bj\"{o}rn and Roitzsch, Michael and H\"{a}rtig, Hermann},
booktitle = {VEE},
doi = {10.1145/1735997.1736001},
file = {:home/peter/Documents/Mendeley Desktop/VEE - 2010 - Capability Wrangling Made Easy Debugging on a Microkernel with Valgrind - Pohle et al.pdf:pdf},
isbn = {9781605589107},
pages = {3--12},
publisher = {ACM},
title = {{Capability Wrangling Made Easy: Debugging on a Microkernel with Valgrind}},
year = {2010}
}
@misc{Mendeley2009c,
address = {London},
annote = {Double click on the entry on the left to view the PDF.},
author = {Mendeley},
booktitle = {Mendeley Desktop},
keywords = {Mendeley},
publisher = {Mendeley Ltd.},
title = {{Getting Started with Mendeley}},
url = {http://www.mendeley.com},
year = {2009}
}
@inproceedings{Song2008,
address = {Hyderabad, India},
author = {Song, Dawn and Brumley, David and Yin, Heng and Caballero, Juean and Jager, Ivan and {Gyung Kang}, Min and Liang, Zhenkai and Newsome, James and Poosankam, Pongsin and Saxena, Prateek},
booktitle = {ISS. Keynote invited paper},
title = {{BitBlaze: A New Approach to Computer Security via Binary Analysis}},
year = {2008}
}
@article{Kleen2004,
author = {Kleen, Andi},
title = {{Linux Kernel Documentation: Virtual memory map with 4 level page tables. http://www.kernel.org/doc/Documentation/x86/x86\_64/mm.txt. Last accessed July 24th, 2011.}},
year = {2004},
}

@article{Burger2009,
author = {Burger, T. W.},
title = {{Intel Virtualization Technology for Directed I/O (VT-d): Enhancing Intel platforms for efficient virtualization of I/O devices. http://software.intel.com/en-us/articles/intel-virtualization-technology-for-directed-io-vt-d-enhancing-intel-platforms-for-efficient-virtualization-of-io-devices/.  Last accessed July 25, 2011.}},
year = {2009},
}

@inproceedings{Palix2011,
 author = {Palix, Nicolas and Thomas, Ga\"{e}l and Saha, Suman and Calv\`{e}s, Christophe and Lawall, Julia and Muller, Gilles},
 title = {Faults in linux: ten years later},
 booktitle = {ASPLOS},
 series = {ASPLOS '11},
 year = {2011},
 isbn = {978-1-4503-0266-1},
 location = {Newport Beach, California, USA},
 pages = {305--318},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/1950365.1950401},
 doi = {http://doi.acm.org/10.1145/1950365.1950401},
 acmid = {1950401},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {fault-finding tools, linux},
} 

@INPROCEEDINGS{Cantrill2004,
author = {Bryan M. Cantrill and Michael W. Shapiro and Adam H. Leventhal and
Sun Microsystems},
title = {Dynamic instrumentation of production systems},
booktitle = {USENIX ATC},
publisher = {USENIX Association},
year = {2004},
pages = {15--28}
}
@inproceedings{Tamches1999,
 author = {Tamches, Ariel and Miller, Barton P.},
 title = {Fine-grained dynamic instrumentation of commodity operating system kernels},
 booktitle = {OSDI},
 year = {1999},
 location = {New Orleans, Louisiana, United States},
 pages = {117--130},
 numpages = {14},
 acmid = {296817},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
} 


@inproceedings{Bruening2010,
author = {Bruening, Derek. and Zhao, Qin}, 
booktitle={CGO},
title={Practical memory checking with Dr. Memory}, 
year={2011}, 
month={april}, 
pages={213-223}, 
}

@inproceedings{Nossum2007,
author={Nossum, Vegard},
title = {{kmemcheck: trap uses of uninitialized memory.  http://lwn.net/Articles/259974/. Last accessed July 25th, 2011.}},
year={2007},
}

@inproceedings{Hofmann2011,
author={Hofmann, Dunn and Kim, Roy and Witchel},
title = {Ensuring operating system kernel integrity with OSck},
publisher = {ASPLOS},
year={2011},
}

@inproceedings{Petroni2007,
author={Nick L. Petroni, Jr. and Michael Hicks},
title = {Automated Detection of Persistent Kernel Control-Flow Attacks},
year={2007},
}

@inproceedings{Xiong_State_Tian_Liu_2011,
author={X. Xiong, D. Tian and P. Liu},
title = {Practical Protection of Kernel Integrity for Commodity OS from Untrusted Extensions},
publisher = {NDSS},
year={2011},
address = {CA, USA},
}

@inproceedings{Feiner_Brown_Goel_2010,
author={ Feiner, Brown and Goel},
title = {A Design for Comprehensive Kernel Instrumentation},
publisher = {HOTDEP},
year={2010},
}

@inproceedings{Garfinkel2003,
author={Tal Garfinkel and Mendel Rosenblum},
title = {A Virtual Machine Introspection Based Architecture for Intrusion Detection},
year={2003},
}

@inproceedings{wampler2008,
author={Doug Wampler and James H. Graham},
title = {A Normality Based Method for Detecting Kernel Rootkits},
year={2008},
}

@inproceedings{TRUSS,
author={Saravanan Sinnaduraiâ€ , Qin Zhao and Weng-Fai Wong},
title = {Transparent Runtime Shadow Stack:Protection against malicious return address  modifications},
}

@inproceedings{HookSafe,
author={Zhi Wang Xuxian, Jiang Weidong and Cui Peng Ning},
title = {Countering Kernel Rootkits with Lightweight Hook Protection},
}

@inproceedings{Witchel2005,
author={Emmett Witchel, Junghwan and Rhee Krste Asanovi},
title = {Mondrix: Memory Isolation for Linux using Mondriaan Memory Protection},
publisher = {SOSP},
year={2005},
address = {Brighton, UK},
}

@inproceedings{Ganapathy2005,
author={Vinod Ganapathy, Matthew J. Renzelmann and Arini Balakrishnanâ€  , Michael M. Swift and Somesh Jha},
title = {The Design and Implementation of Microdrivers},
publisher = {ASPLOS},
year={2008},
address = {Seattle, Washington, USA},
}

@inproceedings{Williams2008,
author={Dan Williams, Patrick Reynolds and Kevin Walsh, Emin G Ìˆ n Sirer and Fred B. Schneider},
title = {Device Driver Safety Through a Reference Validation Mechanism},
}

@inproceedings{Cowan1998,
author={Crispin Cowan and Calton Pu, Dave Maier and Heather Hintony Jonathan Walpole and Peat Bakke, Steve Beattie and Aaron Grier, Perry Wagle and Qian Zhang },
title = {StackGuard: Automatic Adaptive Detection and Prevention of Buffer-Overflow Attacks},
}

@inproceedings{Frantzen2001,
author={Mike Frantzen and Mike Shuey},
title = {StackGhost: Hardware Facilitated Stack Protection},
publisher = {Published in USENIX Security Symposium '01},
year={2001}
}

@inproceedings{Tan2007,
author={L. Tan, E. M. Chan and R. Farivar, N. Mallick and J. C. Carlyle, F. M. David and R. H. Campbell},
title = {ikernel: Isolating buggy and malicious device drivers using hardware virtualization support},
publisher = {DASC},
year={2007}
}

@inproceedings{LeVasseur2004,
author={J. LeVasseur, V Uhlig, J. Stoess and S. Gotz},
title = {Unmodified device driver reuse and improved system dependability via virtual machines},
publisher = {OSDI},
year={2004},
address = {Berkeley, CA, USA}
}

@inproceedings{Xiong2011,
author={Xi Xiong, Donghai Tian and Peng Liu},
title = {Practical Protection of Kernel Integrity for Commodity OS from Untrusted Extensions},
publisher = {NDSS},
year={2011},
address = {San Diego, CA, USA}
}
@article{Srivastava_Giffin_2011, title={Efficient Monitoring of Untrusted Kernel-Mode Execution}, journal={Work}, author={Srivastava, Abhinav and Giffin, Jonathon}, year={2011}}

@article{Srivastava2009,
author = {Srivastava, Abhinav and Giffin, Jonathon},
title = {{Kernel data integrity protection via memory access control}},
journal={Technical report GT-CS-09-05},
year = {2009}
}

@inproceedings{YMao2011,
  author    = {Yandong Mao and
               Haogang Chen and
               Dong Zhou and
               Xi Wang and
               Nickolai Zeldovich and
               M. Frans Kaashoek},
  title     = {Software fault isolation with API integrity and multi-principal
               modules},
  booktitle = {SOSP},
  year      = {2011},
  pages     = {115-128},
  ee        = {http://doi.acm.org/10.1145/2043556.2043568},
  crossref  = {DBLP:conf/sosp/2011},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@proceedings{DBLP:conf/sosp/2011,
  editor    = {Ted Wobber and
               Peter Druschel},
  title     = {Proceedings of the 23rd ACM Symposium on Operating Systems
               Principles 2011, SOSP 2011, Cascais, Portugal, October 23-26,
               2011},
  booktitle = {SOSP},
  publisher = {ACM},
  year      = {2011},
  isbn      = {978-1-4503-0977-6},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@article{Wulf1974, title={HYDRA: the kernel of a multiprocessor operating system}, volume={17}, number={6}, journal={Communications of the ACM}, publisher={ACM New York, NY, USA}, author={Wulf, W and Cohen, E and Corwin, W and Jones, A and Levin, R and Pierson, C and Pollack, F}, year={1974}, pages={337--345}}

@article{cve2012, title={Common vulnerabilities and exposures}, url={http://cve.mitre.org/cgi-bin/cvekey.cgi? keyword=linux+kernel+2012}}

@inproceedings{Riley2008,
 author = {Riley, Ryan and Jiang, Xuxian and Xu, Dongyan},
 title = {Guest-Transparent Prevention of Kernel Rootkits with VMM-Based Memory Shadowing},
 booktitle = {Proceedings of the 11th international symposium on Recent Advances in Intrusion Detection},
 series = {RAID '08},
 year = {2008},
 isbn = {978-3-540-87402-7},
 location = {Cambridge, MA, USA},
 publisher = {Springer-Verlag},
 address = {Berlin, Heidelberg}
}

@inproceedings{Wang2009,
 author = {Wang, Zhi and Jiang, Xuxian and Cui, Weidong and Ning, Peng},
 title = {Countering kernel rootkits with lightweight hook protection},
 booktitle = {Proceedings of the 16th ACM conference on Computer and communications security},
 series = {CCS '09},
 year = {2009},
 isbn = {978-1-60558-894-0},
 location = {Chicago, Illinois, USA},
 pages = {545--554},
 numpages = {10},
 doi = {10.1145/1653662.1653728},
 acmid = {1653728},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {malware protection, rootkits, virtual machines},
}

@inproceedings{Baliga2008,
 author = {Baliga, Arati and Ganapathy, Vinod and Iftode, Liviu},
 title = {Automatic Inference and Enforcement of Kernel Data Structure Invariants},
 booktitle = {Proceedings of the 2008 Annual Computer Security Applications Conference},
 series = {ACSAC '08},
 year = {2008},
 isbn = {978-0-7695-3447-3},
 pages = {77--86},
 numpages = {10},
 doi = {10.1109/ACSAC.2008.29},
 acmid = {1468197},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 keywords = {rootkits, kernel, data structures, invariants, automatic, non-control data, inference},
} 
